[{"categories":null,"content":"业务消息传递技术（AKA Enterprise Messaging），如 IBM MQ、RabbitMQ 和 ActiveMQ，在应用程序内和跨应用程序间提供异步通信技术已经很多年了。 最近，事件流技术（AKA Event Streaming，如 Apache Kafka）越来越流行，它们也提供异步通信。\n开发人员和架构师可能错误地认为在这两种技术之间进行切换的改动会很小。 但在很多场景下，一旦深入了解并真正理解这两种技术存在的意义，以及它们适用的场景， 就会明白它们实际上它们是互补的两种技术，而不是相互竞争。\n在本文中，我们将参考两种异步用例：\n处理请求(request for processing) 访问业务数据(access enterprise data) 以帮助了解更多关于业务消息传递技术和事件流技术的信息。 然后，我们再讨论在为异步通信解决方案做技术选型时要考虑的关键因素。\n异步使用场景 为了了解如何进行技术选型，让我们先了解两种异步场景：\n处理请求(request for processing): 这个场景是一个应用程序向另一个系统或服务发出请求来完成一个操作，然后将响应消息返回给请求者。 这种模式自从有互联网就存在了，而且将来也可能会一直存在。对于同步的、低质量的服务通信，自然而然就会 HTTP，而对于关键任务的通信，首选是异步消息。 要进一步了解何时使用同步或异步通信，请参阅文章 “ APIs 和 Messaging 的介绍 ”。 访问业务数据(access enterprise data): 在这个场景，业务中的组件可以发送描述其当前状态的数据，该数据通常不会直接包含让另一个系统完成某个操作的指令。 相反，组建让其他系统了解它们的数据和状态，这可能是分发和消费使用业务数据的强大机制。 处理请求的场景 业务消息传递技术擅长 处理请求 的场景，包括许多常见的功能：\n会话式消息传递：使用消息传递技术完成 请求/响应交互 的能力。这允许应用程序以 仅请求（即发即弃） 或 请求/响应模式 进行交互，选择最适合该场景的方式进行交互。\n有针对性的可靠交付：当发送一条消息时，会以处理这条消息的特定实体为目标。 可以使用不同等级的消息可靠性，取决于应用程序和消息的重要性。 在关键任务通信的情况下，它应该是一次性、有保证的交付。 在 最多一次 或 至少一次 的交付场景下，可以考虑使用 接受丢失 或 接受重复 的系统。\n短暂的数据持久化：数据仅会存储到被消费者消费或数据过期。 数据不需要持久化超过要求的时间，而且从系统资源占用的角度来看，一直持久保存没有好处。\n访问业务数据的场景 在 访问业务数据 这个场景下核心是发布/订阅（pub/sub）引擎，发布程序发布数据到 topic，然后订阅程序注册消费一个或多个 topic 以接收来自发布程序的数据。 pub/sub 引擎负责分发以确保所有人都能收到想要的数据。它也充当抽象层，使发布和订阅程序解耦，使其具有不同的可用性。\npub/sub 引擎已经存在很多年了，例如首次发布 Apache Kafka 的 2011 年很多年之前， 1998 年发布的 JMS 1.0 规范就已经包含了这个能力。 业务消息技术和事件流技术都提供 pub/sub 引擎，所以可能对于给定的项目到底用哪个更合适会产生混淆。\n许多事件流技术提供 pub/sub 引擎但是也会包含一些其他适合特定场景的附加功能， 可以帮助在区分什么时候应该用业务消息的解决方案。比如，Apache Kafka 擅长：\n流历史（Stream history）：Apache Kafka 会保存 topic 的中的事件，只有当它们过期或达到系统资源限制时才会被移除。 这让订阅者可以重放事件，而不是仅仅只能获取到最近发布的事件。这是消息传递技术 Transient Data Persistence 特性的镜像。\n可扩展订阅（Scalable subscriptions）：流历史允许 Apache Kafka 可以通过轻量级的方法扩展订阅者的数量。 每个订阅者在流历史记录中都有一个指针来代表它已经消费的位置，这极大限度地减少了新订阅者的开销。 这也让 Apache Kafka 能以最小的影响支持上千，甚至上万的订阅者同时订阅同一个 topic。\n在业务消息传递技术和事件流技术之间进行选择 就像上面所提到的，业务消息传递技术和事件流技术有不同所擅长的功能，但是也有一些相同的功能。 所以关键是为解决方案选择合适的技术，而不是强制进行配合。\n为了促进本次评估，在为解决方案选择合适的技术时，需要考虑以下关键的标准：\n事件历史 细粒度的订阅 可扩展的消费 事务操作 事件历史 解决方案是否需要能够在正常或故障的情况下取回历史事件？ 在消息传递 pub/sub 模型中，事件会被发布到一个 topic。 一旦当它被订阅者收到，topic 就有责任存储此信息以备未来使用。 在某些情况下， pub/sub 模型可以保留最后的发布，但是让消息传递技术存储历史事件不太常见。 而对于 Apache Kafka，保存事件历史是架构的基础，唯一的问题是要保存多少和保存多久。 在许多用例场景下，存储历史记录至关重要，但是在一些其他用例场景中，从安全和系统资源的角度来看，这可能并不是最好的方案。\n细粒度的订阅 当一个 topic 被 Apache Kafka 创建之后，会创建一个或多个 partition 。 partition 是 Apache Kafka 基本架构的概念，并提供了扩展解决方案以处理大量事件的能力。 每一个 partition 独自占用资源，通常建议将单个集群中的 topic 数量限制为几百或几千个。\n业务消息传递 pub/sub 技术有一个更灵活的机制，topic 是可以分层的结构，比如 /travel/flights/airline/flight-number/seat， 每个层次都可以订阅。这让订阅程序可以更细粒度地选择事件。此外，业务消息传递 pub/sub 技术可以用于进一步细化感兴趣的事件。\n订阅业务消息 pub/sub 系统的程序接收与他们无关的事件的可能性要小得多， 然而对于订阅 Apache Kafka 且可能只需要一小部分事件的程序，在刚开始处理时需要过滤程序来过滤掉不需要的事件。\n可扩展的消费 如果 100 个订阅者订阅了一个 topic 中的所有事件，业务消息传递技术需要为每个发布事件都创建 100 条消息。 如果要求它们的每一个都要存储而且持久化保存到磁盘，对于 Apache Kafka 来说，事件只会被写入一次，每个消费者都有一个对应于所在事件历史位置的索引。 而对于 IBM MQ 等消息传递技术可以有更高的可扩展性，所以根据事件数量和订阅者的数量这些因素可能可以决定最适合的技术，但也需要根据实际情况再进行分析。\n事务操作 IBM MQ 等业务消息传递技术和 Apache Kafka 等事件流技术都提供了事务操作 API 来处理事件。 然而，这两种实现的工作方式不同，因此不能相互兼容。 IBM MQ 提供原子性（Atomicity），一致性（Consistency），隔离性（Isolation）和 持久性（Durability）的 ACID 属性， 但是这些在 Apache Kafka 中并不能得到保证。 通常在 pub/sub 解决方案中，IBM MQ 特定的事务性操作不像处理请求的场景那么重要，所以了解其中的差异非常重要。\n了解更多事务需要考虑的因素，可以看这篇文章 “ Does Apache Kafka do ACID transactions? ”。\n总结以及扩展阅读 总而言之，虽然业务消息传递技术和事件流技术可能最初看起来是重叠的，但适用的用例和场景其实不同。 消息传递技术更擅长请求处理的场景，而事件流技术专门提供具有流历史的 pub/sub 引擎。 这两个技术确实天然互补，所以客户通常对两者都有需求。\n想要更深入的了解这两个技术，请看这个在 2020 年 TechCon 大会的演示文稿 “ MQ and Kafka, what’s the difference? ”(或者看视频回放)。\n原文：Why enterprise messaging and event streaming are different\n","description":"","tags":["Message","Event Streaming","MQ","Kafka"],"title":"业务消息传递(AKA Enterprise Messaging) 和 事件流（AKA Event Streaming）的区别","uri":"/posts/event-streaming-vs-enterprise-messaging/"},{"categories":null,"content":" 2022 Jun Sat 06/04 18:07 花了一天多时间，终于把这个 emo list 完成了，感谢 @ankang 帮忙做的一些前端工作 👏🏻👏🏻👏🏻 后续应该还要支持图片，争取明天完成 ✊🏻\n","description":"","tags":null,"title":"","uri":"/emo/"},{"categories":null,"content":" 敬维 Stay hungry, stay foolish. 以认真的态度做完美的事情。 老张的博客 我是从事LAMP平台下互联网项目的老兵(张素杰)。 DigDeeply，专业IT。技能：架构设计、PHP、PHP扩展、Golang、OpenResty、Python、K8S ... JerryQu 的小站 屈屈，专职前端开发，目前在中国北京。这个博客是我随便记录东西的地方。 ankang.icu 一个菜鸟的学习记录，专注前端开发 Cuetorials CUE 是一门逻辑语言，专门用于处理配置、结构、数据并执行它们。 卡拉云 可以帮你快速搭建后台系统，多有时间专注核心业务，提升企业运营效率。 CYYJS Cyy的个人网站、博客、全栈开发技术分享 咀嚼之味 关于JS的文章写的非常棒。润阳是少数技能能力出众且写作也超群的工程师，非常推荐 Stephen's Blog 心有猛虎，细嗅蔷薇。来自8D魔幻城市—重庆，一直努力行走在全栈的路上。 ","description":"","tags":null,"title":"","uri":"/links/"},{"categories":null,"content":"对于业务应用程序的要求不断提高，但是 IT 部门困于大量的应用程序积压的工作而不可能很快的完成工作。而且，目前面临的挑战是，IT 需要重新思考提高交付速度的方法。有两个解决方案：low-code 和 serverless。\n但什么是 low-code 和 serverless？还有更重要的是，这一切又与 IoT 有什么关系？放轻松，我最终会解释。但是首先，让我们看一下 low-code 和 serveless，如果你还不熟悉这些技术，能让你快速熟悉起来。\n冰与火之歌 low-code 和 serverless 技术同样都是为了简化应用开发流程而设计的，从而加速新应用程序的交付。serverless 通过减轻开发人员的服务器管理负担来做到这一点。虽然 serverless 的名字可能暗示没有任何服务器，但是还是需要服务器的。只是从开发者的角度来看，他只需要简单地专注于应用的开发而不是要担心部署、管理和扩容服务器。\n另一方面，low-code 通过从代码中抽象出开发人员来简化应用程序开发。思路是，如果开发人员可以拖放 GUI 组建来创建用户界面，然后用类似流程图的方式来创建业务逻辑，他将更快的交付应用程序。\n两个技术的存在都是为了解决同样的问题：加速应用程序开发。然而，两项技术背后的公司可能会采取截然不同的方法，导致 serverless 和 low-code 看起来像是冰与火。\n公有云供应商比如 AWS、Google、Azure 和 IBM 都提供 serverless 选择，但是对于他们的大多数，他们只关注于低等级功能，大多数组织无法基于这些技术解决复杂的问题。直接与这些供应商合作的组织可以更好的控制输出，但是这需要更多的开发工作。\n同时，传统的 low-code 供应商通过让商业用户可以访问应用程序的开发，来预示着“全民开发者“的兴起。鉴于大多数商业用户都没有计算机相关学位，low-code 的方法非常适合他们。不像 serverless 那样，low-cdoe 让应用程序交付更快，但是以可控性为代价 – 开发者在供应商设置的 low-code 环境下可做的事情受到很大限制。\n异性相吸：冰与火的结合 随着找到应用程序开发挑战解决方案的压力越来越大，这些技术没有理由不能共存。只是传统 low-code 供应商早于 serverless 的概念，并使用需要应用服务器的传统技术。是的，应用服务器被认为是过时的技术，即使他们是开源的！而且给全民开发者提供 low-code 的方法也不是 AWS、Google 或 IBM 的 DNA。 Microsoft 有一点不同，但其业务开发工作目前并未与 serverless 相关联。\n所以，这回带来什么问题？对于寻找 low-code 选项的人来说，他们应该仔细考虑系统的架构。这可能会很难，因为供应商喜欢到处乱用技术名称，那将会让调研变得复杂。不幸的是，实际上很多传统的 low-code 供应商都依赖较旧的技术。相比于 serverless，你可以认为他们是单体架构 – 那意味着你没有对于 设计、开发、测试、部署、独立扩展能力的可灵活性。\n好消息是，现在有很多 low-code 的可选项是基于 serverless 的。它们采取不同的方法，通过关注于提高专业开发人员的生产力而不是将应用程序开发人员的责任转移给全民开发者。本质上，它们旨在通过使用现有的工具和流程设计的通用 web 技能为开发人员提供更高级别的控制。\nServerless、low-code 和 IoT 应用程序经验 所以，为什么这一切对于 IoT 很重要？传统的 low-code 吹捧支持 IoT 应用程序的能力。但是他们仅限于调用打包的服务（比如 分析）和在应用程序中使用服务。\n另一方面，serverless 对于 IoT 来说是非常好的架构，因为 event-based 工作方式在 serverless 环境运行的非常好。而且 event-based 是 IoT 应用程序的关键，因为来自传感器数据分析的事件可以实现更自然的、中断驱动的应用体验。这允许应用程序代表用户执行操作，从而最大限度地减少用户必须做的工作。\n因此，如果您正在考虑 low-code ，请确保要仔细考虑系统的架构，而不是只关注拖放式 UI —— 它可以对最终产品产生重大影响。\n","description":"","tags":["low-code","serverless"],"title":"low-code 和 serverless – 冰与火？","uri":"/posts/lowcode-and-serverless/"},{"categories":null,"content":"\n托 团队 leader 的福，白嫖了今年 GopherCon China 的票，和历届大会相比，第二天分了两个分会场， 分享不同的内容，参会者可以根据个人兴趣自行选择参加。\n然而不得不说，本次和之前几次的分享安排相比，多了一些针对自己公司产品的推广。 但不管怎么说，收获还是有的，印象比较深的 talk 有 PingCAP CEO 黄东旭分享的《全链路可观测性：从应用到 Go Runtime》，比较有趣；还有曹大曹春晖分享的《Go 语言的抢式调度》，内容确实很卷很深入。\n大会提到的很多技术其实我们团队也早已经实践使用，比如鸟窝在《深入探究 Go Module》中分享如何使用 GOPRIVATE 从而使用自己的私有仓库； Grab 公司在分享《Improving Go Backend Developer Experience In Grab》中提到的 CI/CD 我们也已经在我们大多数项目中使用。\n我总结了讲师提到最多的关键词，一方面也能体现业内目前在流行什么：\nK8S：毋庸置疑，云原生时代的王者 API Gateway、L7 Banlancer：处理南北向流量，两者定位不同又有一部分功能重合，APISIX、BFE 最近两年大家讨论比较多的开源项目 Service Mesh：处理东西向流量，Envoy、xDS协议 微服务：不再赘述 Tracing、Metrics、Logging：及时发现服务问题 CI/CD：加快应用的部署速度，解放开发者双手不可或缺的步骤 Rust：没错，Gopher 大会确实多次提到了 Rust 语言 我针对我自己参加的几个分享谈一谈我自己的一些感受和思考。\n大会的 PPT，可以在这里获取：https://mp.weixin.qq.com/s/734ac0JeQtSrzcmZ1-so8w\n《Generic in go》 大会第一场是跟老外连线，但是直播断断续续，我这蹩脚听力更听不懂了，体验不太好。但是针对泛型这个主题，在社区中有很多讨论， 也有一些争议，主要是泛型的支持者，和认为加入泛型破坏 golang 简单特性的反对者， 不过今年官方正式提出将泛型特性加入 Go 的 proposal https://blog.golang.org/generics-proposal https://github.com/golang/go/issues/43651 。 而且，golang 官方已经在 master 分支实现了泛型，鸟窝也在早些时间给出了 Go 泛型尝鲜的方法：https://colobu.com/2021/03/22/try-go-generic/\n《MOSN在云原生的探索和实践》 MOSN 是一款网络代理软件，可以与任何支持 xDS API 的 Service Mesh 集成，也具备南北向流量代理的功能。 不得不佩服 MOSN 对 CGO 的调研和使用深度，其中介绍的 MOE（Mosn on Envoy）使得 MOSN 底层网络具备 C 同等处理能力的同时， 又能使上层业务可高效复用 MOSN 的处理能力及 Golang 高效的开发效率。\n《浅谈全链路可观测性：从应用到Go Runtime》 我个人认为很不错的分享，由浅入深带领大家如何 Trace In Go Runtime，PPT 风格还有讲解风格都很有趣。 最终的实现方式我也没想到和我最近翻译的这篇文章相关 （ 深入剖析 Golang Pprof 标签 ）， 翻译时也没想到还能这么玩，当时听了确实也令人眼前一亮。\n《Improving Go Backend Developer Experience in Grab》 算是 Grab 公司的经验分享，关于整个软件的设计、开发和交付流程。和 Go 的关系并不是很大，很多经验经验也很难进行复制。\n《利用夜莺扩展能力打造全方位监控体系》 夜莺也是国内应用很火的监控系统，和 Prometheus 相比，有一些优势吧，比如有自身的告警平台， 我们团队内部使用的基于 Prometheus 又另外开发的一套报警系统，目前也是开源，地址是 https://github.com/Qihoo360/doraemon 。 更多夜莺和Prometheus的对比可以看这篇分析文章，《夜莺与Prometheus的对比》 。 但是干货太少，全程介绍产品功能。\n《如何构建易于拆分的单体应用》 由于项目的特殊性，我们组内大多数应用都是单体应用，也在尝试做一些微服务的拆分工作。这个分享虽然没讲 DDD， 但从现实例子出发，分析一个应用如何设计、开发，同时实战讲解了如何使用 go-kit 构建一个简单的应用，还是有些收获。\n《深入探索Go Module: 实践、技巧和陷阱》 内容充实还不错，一些比较常见的用法我们团队也一直在用，我们的也是去年开始从 dep 全部换到了 go module， 所以积累了一些 go module 的使用经验，所以整个分享听下来也比较轻松。我之前也写了一篇文章介绍如何让 go module 使用 gitlab 私有仓库：https://h1z3y3.me/posts/go-private-git-repository/ 。 鸟窝还介绍了一些之前基本没用过的子命令，比如 go mod graph、go mod why，收获最大的是终于弄明白了 go module 拉取依赖包的策略。\n《深入理解 BFE》 也算是推广分享，介绍 BFE 产品，没什么干货。\n我们 19 年也开源了一个七层转发的代理 「HTTPS Layer」 ， 和 BEF 相比，功能基本类似，甚至可以说 80% 相同。最大的区别就是 BFE 基于 Go 生态，我们基于 Openresty 生态。 或许缺少了维护和宣传，我们并没有获得很高的关注，比较可惜。其实 HTTPS Layer 在我们公司内部也得到了生产环境的验证， 做了一些分布式部署之后，目前我们单机房峰值 QPS 也能达到 10w QPS，当然还预留了一些 buffer 的情况下。\n《Go 语言的抢占式调度》 曹大曹春晖的分享，很卷，讲解了 GMP 模型以及 Golang 的抢占式调度，干货又太干了，有点吸收不了。 主要内容是 golang 1.14 版本前后两种不同的抢占式调度模型，深入源码，通过编译后的汇编进行讲解，挺有深度的，之后会再仔细研究这方面的知识。\n《K8S私有云建设实践》 公司的经验分享，不可复制，因为太客制化了。为了迎合公司现有平台，抛弃了很多 k8s 的原生用法，我个人觉得很鸡肋。 针对私有云建设，360 其实走在比较前面，之前还开源了 k8s 的多集群管理平台 Wayne ，开源初期获得很多关注，但是后续也不没有持续更新，也比较可惜。\n《Go 如何助力企业进行微服务转型》 go-zero 的维护者万俊峰分享，虽然经验之谈多一些，关于 Go 的讨论少，但是整体分享是好分享，收获很多， 也有些之后可借鉴的点。不多赘述，PPT 可以下载下来看，里面挺详细。\n总结 从整体来看，本次 Gopher 大会还算成功，有些小插曲，但是瑕不掩瑜。只是希望之后能少一些对于产品的推广和介绍， 对于产品功能完全可以去看各自产品的文档，我能想到他们和 Go 唯一相关的就是这个产品是 Go 写的。 作为技术人花了钱到这里想看到的还是对于 Go 的一些可借鉴和可复制的实践经验，这个其实看下国外的 gopher 大会就能体会到了。\n不管怎么说，虽然周末两天都没睡懒觉，7点早起就往会场赶，但是最后还是心满意足。我看大会全程有录像， 大家可以参考我的思考，去翻翻对应的 PPT 或者视频，相信也能有所收获！\n","description":"","tags":["Golang"],"title":"2021 北京 Gopher 大会","uri":"/posts/gophercon-china-2021/"},{"categories":null,"content":"在本文中，我们将了解反向代理，它的应用场景以及如何在 Golang 中实现它。\n反向代理是位于 Web 服务器前面并将客户端（例如 Web 浏览器）的请求转发到 Web 服务器的服务器。 它们让你可以控制来自客户端的请求和来自服务器的响应，然后我们可以利用这个特点， 可以增加缓存、做一些提高网站的安全性措施等。\n在我们深入了解有关反向代理之前，让我们快速看普通代理（也称为正向代理）和反向代理之间的区别。\n在正向代理中，代理代表原始客户端从另一个网站检索数据。 它位于客户端（浏览器）前面，并确保没有后端服务器直接与客户端通信。 所有客户端的请求都通过代理被转发，因此服务器只与这个代理通信（服务器会认为代理是它的客户端）。 在这种情况下，代理可以隐藏真正的客户端。\n另一方面，反向代理位于后端服务器的前面，确保没有客户端直接与服务器通信。 所有客户端请求都会通过反向代理发送到服务器，因此客户端始终只与反向代理通信， 而从不会直接与实际服务器通信。 在这种情况下，代理可以隐藏后端服务器。 几个常见的反向代理有 Nginx， HAProxy。\n反向代理使用场景 负载均衡（Load balancing）： 反向代理可以提供负载均衡解决方案，将传入的流量均匀地分布在不同的服务器之间，以防止单个服务器过载。\n防止安全攻击： 由于真正的后端服务器永远不需要暴露公共 IP，所以 DDoS 等攻击只能针对反向代理进行， 这能确保在网络攻击中尽量多的保护你的资源，真正的后端服务器始终是安全的。\n缓存： 假设你的实际服务器与用户所在的地区距离比较远，那么你可以在当地部署反向代理，它可以缓存网站内容并为当地用户提供服务。\nSSL 加密： 由于与每个客户端的 SSL 通信会耗费大量的计算资源，因此可以使用反向代理处理所有与 SSL 相关的内容， 然后释放你真正服务器上的宝贵资源。\nGolang 实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import ( \"log\" \"net/http\" \"net/http/httputil\" \"net/url\" ) // NewProxy takes target host and creates a reverse proxy // NewProxy 拿到 targetHost 后，创建一个反向代理 func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } return httputil.NewSingleHostReverseProxy(url), nil } // ProxyRequestHandler handles the http request using proxy // ProxyRequestHandler 使用 proxy 处理请求 func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { proxy.ServeHTTP(w, r) } } func main() { // initialize a reverse proxy and pass the actual backend server url here // 初始化反向代理并传入真正后端服务的地址 proxy, err := NewProxy(\"http://my-api-server.com\") if err != nil { panic(err) } // handle all requests to your server using the proxy // 使用 proxy 处理所有请求到你的服务 http.HandleFunc(\"/\", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(\":8080\", nil)) } 是的没错！这就是在 Go 中创建一个简单的反向代理所需的全部内容。 我们使用标准库 net/http/httputil 创建了一个单主机的反向代理。 到达我们代理服务器的任何请求都会被代理到位于 http://my-api-server.com。 如果你对 Go 比较熟悉，这个代码的实现一目了然。\n修改响应 HttpUtil 反向代理为我们提供了一种非常简单的机制来修改我们从服务器获得的响应， 可以根据你的应用场景来缓存或更改此响应，让我们看看应该如何实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // NewProxy takes target host and creates a reverse proxy func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } proxy := httputil.NewSingleHostReverseProxy(url) proxy.ModifyResponse = modifyResponse() return proxy, nil } func modifyResponse() func(*http.Response) error { return func(resp *http.Response) error { resp.Header.Set(\"X-Proxy\", \"Magical\") return nil } } 可以在 modifyResponse 方法中看到 ，我们设置了自定义 Header 头。 同样，你也可以读取响应体正文，并对其进行更改或缓存，然后将其设置回客户端。\n在 modifyResponse 中，可以返回一个错误（如果你在处理响应发生了错误）， 如果你设置了 proxy.ErrorHandler, modifyResponse 返回错误时会自动调用 ErrorHandler 进行错误处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // NewProxy takes target host and creates a reverse proxy func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } proxy := httputil.NewSingleHostReverseProxy(url) proxy.ModifyResponse = modifyResponse() proxy.ErrorHandler = errorHandler() return proxy, nil } func errorHandler() func(http.ResponseWriter, *http.Request, error) { return func(w http.ResponseWriter, req *http.Request, err error) { fmt.Printf(\"Got error while modifying response: %v \\n\", err) return } } func modifyResponse() func(*http.Response) error { return func(resp *http.Response) error { return errors.New(\"response body is invalid\") } } 修改请求 你也可以在将请求发送到服务器之前对其进行修改。 在下面的例子中，我们将会在请求发送到服务器之前添加了一个 Header 头。 同样的，你可以在请求发送之前对其进行任何更改。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // NewProxy takes target host and creates a reverse proxy func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } proxy := httputil.NewSingleHostReverseProxy(url) originalDirector := proxy.Director proxy.Director = func(req *http.Request) { originalDirector(req) modifyRequest(req) } proxy.ModifyResponse = modifyResponse() proxy.ErrorHandler = errorHandler() return proxy, nil } func modifyRequest(req *http.Request) { req.Header.Set(\"X-Proxy\", \"Simple-Reverse-Proxy\") } 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package main import ( \"errors\" \"fmt\" \"log\" \"net/http\" \"net/http/httputil\" \"net/url\" ) // NewProxy takes target host and creates a reverse proxy func NewProxy(targetHost string) (*httputil.ReverseProxy, error) { url, err := url.Parse(targetHost) if err != nil { return nil, err } proxy := httputil.NewSingleHostReverseProxy(url) originalDirector := proxy.Director proxy.Director = func(req *http.Request) { originalDirector(req) modifyRequest(req) } proxy.ModifyResponse = modifyResponse() proxy.ErrorHandler = errorHandler() return proxy, nil } func modifyRequest(req *http.Request) { req.Header.Set(\"X-Proxy\", \"Simple-Reverse-Proxy\") } func errorHandler() func(http.ResponseWriter, *http.Request, error) { return func(w http.ResponseWriter, req *http.Request, err error) { fmt.Printf(\"Got error while modifying response: %v \\n\", err) return } } func modifyResponse() func(*http.Response) error { return func(resp *http.Response) error { return errors.New(\"response body is invalid\") } } // ProxyRequestHandler handles the http request using proxy func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) { return func(w http.ResponseWriter, r *http.Request) { proxy.ServeHTTP(w, r) } } func main() { // initialize a reverse proxy and pass the actual backend server url here proxy, err := NewProxy(\"http://my-api-server.com\") if err != nil { panic(err) } // handle all requests to your server using the proxy http.HandleFunc(\"/\", ProxyRequestHandler(proxy)) log.Fatal(http.ListenAndServe(\":8080\", nil)) } 反向代理非常强大，如文章之前所说，它有很多应用场景。你可以根据你的情况对其进行自定义。 如果遇到任何问题，我非常乐意为你提供帮助。 如果你觉得这篇文章有趣，请分享一下，让更多 gopher 可以阅读！ 非常感谢你的阅读。\nvia: https://blog.joshsoftware.com/2021/05/25/simple-and-powerful-reverseproxy-in-go/\n作者：Anuj Verma 译者：h1z3y3 校对：校对者ID\n本文由 GCTT 原创编译，Go 中文网 荣誉推出\n","description":"","tags":["golang"],"title":"Go 简单而强大的反向代理（Reverse Proxy）","uri":"/posts/simple-and-powerful-reverse-proxy-in-golang/"},{"categories":null,"content":"While using values in a html template, my colleague faced a problem that the values in \u003cscript\u003e tags were all escaped. So the template developer can not use the values in javascript. It just looks like this:\n// ... \u003cscript type=\"text/json\" id=\"channel\" ch=\"recommend\" tk=\"\"\u003e [\u0026#34;news\u0026#34;,\u0026#34;comedy\u0026#34;,\u0026#34;cartoon\u0026#34;,\u0026#34;tech\u0026#34;,\u0026#34;travelling\u0026#34;,\u0026#34;fashion\u0026#34;,\u0026#34;photograph\u0026#34;,\u0026#34;household\u0026#34;,\u0026#34;movies\u0026#34;,\u0026#34;foods\u0026#34;,\u0026#34;military\u0026#34;,\u0026#34;health\u0026#34;,\u0026#34;test\u0026#34;] \u003c/script\u003e // ... I tried to find out the reason. So I copied the template values in other HTML tags, like \u003cdiv\u003e, rather than in \u003cscript\u003e. It rendered correctly, and was not escaped:\n// ... \u003cdiv\u003e [\"news\",\"comedy\",\"cartoon\",\"tech\",\"travelling\",\"fashion\",\"photograph\",\"household\",\"movies\",\"foods\",\"military\",\"health\",\"test\"] \u003cdiv\u003e // ... I start google the reason. At first, I thought it was because the values given template is wrong, it had already been escaped before the page rendering. I found some reasons in google, they said using json.NewEncoder() instead of using json.Marshal(). So it can SetEscapeHTML(false) before encode the data. This is the example code:\n1 2 3 4 5 6 7 8 9 10 func toRawJson(v interface{}) (string, error) { buf := new(bytes.Buffer) enc := json.NewEncoder(buf) enc.SetEscapeHTML(false) err := enc.Encode(\u0026v) if err != nil { return \"\", err } return strings.TrimSuffix(buf.String(), \"\\n\"), nil } I tried it, but didn’t work either.\nNow, let’s think about for a moment. Only \u003cscript\u003e has the problem, but other html tags did not. So if I could say the value is actually correct, but the template rendered in wrong ?\nI started google the problems about template render but not the wrong value.\nThen I found the html/template official document:\nLet’s see its introduction: html/template introduction:\nThis package wraps package text/template so you can share its template API to parse and execute HTML templates safely.\ntmpl, err := template.New(\"name\").Parse(...) // Error checking elided err = tmpl.Execute(out, data) If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode.\nHTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts. The security model used by this package assumes that template authors are trusted, while Execute’s data parameter is not. More details are provided below.\nExample\nimport \"text/template\" ... t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`) err = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\") produces\nHello, \u003cscript\u003ealert('you have been pwned')\u003c/script\u003e! but the contextual autoescaping in html/template\nimport \"html/template\" ... t, err := template.New(\"foo\").Parse(`{{define \"T\"}}Hello, {{.}}!{{end}}`) err = t.ExecuteTemplate(out, \"T\", \"\u003cscript\u003ealert('you have been pwned')\u003c/script\u003e\") produces safe, escaped HTML output\nHello, \u0026lt;script\u0026gt;alert(\u0026#39;you have been pwned\u0026#39;)\u0026lt;/script\u0026gt;! 🥳🥳🥳 Now we find out the reason, but how we solve this problem?\nMaybe I could provide a function to unescape the value in templates.\n1 2 3 4 5 6 7 r := gin.Default() funcMap[\"unescapeHTML\"] = func(s string) template.HTML { return template.HTML(s) } r.SetFuncMap(funcMap) Then you can use it in templates as below:\n// ... \u003cscript type=\"text/json\" id=\"channel\" ch=\"recommend\" tk=\"\"\u003e {{ .channel_data | unescapeHTML }} \u003c/script\u003e // ... Finally, it works. When the template is loaded, the value won’t be escaped!\n// ... \u003cscript type=\"text/json\" id=\"channel\" ch=\"recommend\" tk=\"\"\u003e [\"news\",\"comedy\",\"cartoon\",\"tech\",\"travelling\",\"fashion\",\"photograph\",\"household\",\"movies\",\"foods\",\"military\",\"health\",\"test\"] \u003c/script\u003e // ... Hope this helps you!! Thanks for reading :)\n","description":"","tags":["Golang"],"title":"Unescape values in html templates using golang","uri":"/posts/go-html-template-script-unescape/"},{"categories":null,"content":"Go Module 使用 gitlab 私有仓库 包管理是 Go 一直被诟病做的不好的功能。在 1.11 之前，go get 缺乏对依赖包版本管理和 reproducible build 的支持。 当时在 Go 社区当时诞生了许多好用的工具，比如 glide，dep 等。 在 1.11 版本之后， Go 引入了 Go Module，再也没有 GOPATH 的限制，你可以随意在任何路径写项目，但是此时对私有仓库的支持还不是很好。 而在 1.13 版本之后， Go 对 Go Module 又进行了优化，支持了 GOPRIVATE 环境变量，可以指定私有仓库的地址，使用十分便捷。 大家在使用过程中，或多或少地会遇到一些问题，下面我针对自己遇到的问题进行总结。\ngo get 如果在没有进行任何设置的情况下直接执行 go get your.gitlab.com/pkg/example，你很可能会遇到以下错误：\ngo get: module your.gitlab.com/pkg/example: git ls-remote -q origin in /go/pkg/mod/cache/vcs/a39fc2dbfb0a9645950d24df5d7e922bb7a6a877aecfe2b20f74b96385a83109: exit status 128: fatal: could not read Username for 'https://your.gitlab.com': terminal prompts disabled Confirm the import path was entered correctly. If this is a private repository, see https://golang.org/doc/faq#git_https for additional information. 其实错误提示已经把解决方案给到我们了，我们只需要点击 https://golang.org/doc/faq#git_https 查看即可。\n下面是原文：\nWhy does “go get” use HTTPS when cloning a repository? Companies often permit outgoing traffic only on the standard TCP ports 80 (HTTP) and 443 (HTTPS), blocking outgoing traffic on other ports, including TCP port 9418 (git) and TCP port 22 (SSH). When using HTTPS instead of HTTP, git enforces certificate validation by default, providing protection against man-in-the-middle, eavesdropping and tampering attacks. The go get command therefore uses HTTPS for safety.\nGit can be configured to authenticate over HTTPS or to use SSH in place of HTTPS. To authenticate over HTTPS, you can add a line to the $HOME/.netrc file that git consults:\nmachine github.com login USERNAME password APIKEY For GitHub accounts, the password can be a personal access token. Git can also be configured to use SSH in place of HTTPS for URLs matching a given prefix. For example, to use SSH for all GitHub access, add these lines to your ~/.gitconfig:\n[url \"ssh://git@github.com/\"] insteadOf = https://github.com/ 大概意思是，HTTPS 更安全，所以 go get 命令使用 HTTPS。\n如果你要用 HTTPS，那你就需要配置 HTTPS 的用户名和密码：\nmachine github.com login USERNAME password APIKEY 当然也可以使用 ssh，需要修改你的 git 配置，\n修改当前用户的 ~/.gitconfig，添加：\n[url \"ssh://git@your.gitlab.com/\"] insteadOf = https://your.gitlab.com/ 另外执行下面的命令也能达到同样的效果：\n1 git config --global url.\"git@your.gitlab.com/\".insteadof \"https://your.gitlab.com/\" 操作完之后，我们就可以使用 go get 了，使用 go get -v 可以展示执行日志。\nGONOPROXY 众所周知，国内用户大多设置代理，我们在 Go 1.12 之前如果使用 GOPROXY 这个环境变量设置代理，并使用私有仓库，很有可能会遇到下面的错误：\ngo get your.gitlab.com/pkg/example: module your.gitlab.com/pkg/example: reading https://goproxy.cn/your.gitlab.com/pkg/example/@v/list: 404 Not Found 这是因为代理服务不可能访问到我们的私有代码仓库，所以报错 404。而且，就算使用上文提到的 ssh 鉴权也不行。\nGo 1.13 后可以设置 GONOPROXY 这个环境变量来指定不使用代理的域名，支持逗号分隔多个值。\nGONOSUMDB go mod 需要对下载后的依赖包进行 checksum 校验，当你的 git 仓库是开放的话没问题，但是如果是不可访问的私有仓库，甚至在公司内网。 很可能出现校验失败的错误：\n1 2 get \"your.gitlab.com/pkg/example\": found meta tag get.metaImport{Prefix:\"your.gitlab.com/pkg/example\", VCS:\"git\", RepoRoot:\"https://your.gitlab.com/pkg/example.git\"} at //your.gitlab.com/pkg/example?go-get=1 verifying your.gitlab.com/pkg/example@v0.0.0: your.gitlab.com/pkg/example@v0.0.0: reading https://sum.golang.org/lookup/your.gitlab.com/pkg/example@v0.0.0: 410 Gone 和代理一样，我们的私有仓库对 sum.golang.org 是不可见的，所以肯定没办法执行安全校验。\n同样的在 Go 1.13 后可以设置 GONOSUMDB 环境变量指定跳过校验的的域名，支持逗号分割多个值。\nGOPRIVATE 最后 Go 1.13 还引入的 GOPRIVATE 环境变量，可以说设置后一劳永逸，能自动跳过 proxy server 和 校验检查， 这个变量值也支持逗号分割，可以填写多个值，如：\n1 GOPRIVATE=*.corp.example.com,your.gitlab.com 当然，设置 GOPRIVATE 之后，还可以在通过 GONOPROXY 和 GONOSUMDB 来单独进行控制，\n不过需要注意下 GOPRIVATE 失效的问题，\n举个例子，如果公司内部有私有仓库：your.corp.com，如果这样设置：\n1 2 3 GOPRIVATE=your.corp.com GOPROXY=https://goproxy.cn GONOPROXY=none 因为 GONOPROXY 的值是 none，那么用户还是会从 GOPROXY 的地址下载所有私有和共有的仓库， 此时可能还是会报错，GONOSUMDB 同理，大家注意一下这个问题。\n","description":"","tags":["Golang"],"title":"go module 使用 gitlab 私有仓库","uri":"/posts/go-private-git-repository/"},{"categories":null,"content":"译者注：在翻译这篇文章之前，我自己其实对 Bob 大叔的 Clean Architecture 也做过一些研究，在项目中实践之后， 也确确实实体验到了分层的魅力。在层与层之间将依赖进行隔离，各个层只关注自己本身的逻辑， 所以能让开发者只关注本层的业务逻辑， 也更容易进行单元测试，无形中就提高了你代码的质量和可阅读性。 我觉得如果你对自己的代码有追求，就一定要去学习一下 Clean Architecture。 当然另一方面，Clean Architecture 也不是银弹，在复杂的项目中确实能帮助我们解藕，但是如果你的项目非常简单， 那传统的 MVC 就足够了，就像本文作者最后说的，千万不要让简单的事情变复杂。 另外，其实对于 Golang 的项目组织方式，github 上面火许多 star 非常多的项目，大多开箱即用， 比如： go-gin-api （国人开源的）、 go-clean-arch ，这里分享给大家，也是给大家提供更多的选择。\n以下是原文：\n一个 main.go 文件，几个 HTTP handler 就可以构建一个新的 HTTP 服务。然而，当你开始添加更多的路由规则， 开始将不同的功能拆分到不同的文件中，可能会随处创建好多 packages ，但是你不确定长远来看将会它们怎样发展， 同时你也希望它们能够随着服务增长而有意义。\n这几年我经历过几次这样的场景，后来读了一些文章、博客还有 Robert Martin 的 Clean Architecture (干净架构)， 我找到了一种适合我的通用的代码结构，所以我想我应该分享出来。需要注意的是它可能并不能刚好适合你的应用场景，特别是一些特别简单的服务， 比如说一个 main.go 文件，几个 packages 就已经足够的服务。\n让我们直接开始！\n概览 Go-Service - cmd/ - api/ - pkg/ - api/ - db/ - services/ - serviceA/ - serviceB/ - ... - utils/ - docker-compose.yml - Dockerfile - Makefile - go.mod - go.sum - \u003cenvironment\u003e.env - README.md - ... 整个结构有 3 个重要的部分：root（译者注：根目录）、cmd 和 pkg。我将逐个解释各个文件夹的职责， 然后我们再来仔细看看每个 service (pkg/service/...) 如何组织。\nRoot（根目录） 我喜欢将一些启动和运行的代码放到根目录，比如：构建工具、配置文件、依赖管理等等。 它也提供给阅读代码的人或开发代码的人一个很好的切入点，他们启动服务所需的所有配置都在项目根目录下。\nCmd 这里会被分成几个目录，每个目录都是我们整个服务一部分，比如 API 服务，定时脚本任务等等。 实际上这里会有各子服务的 main package，所以我们在这里初始化配置和我们需要的依赖包，最后子服务会被编译成对应的二进制来提供服务。\nPkg 这里包含了我们项目的主要部分：定义我们服务业务逻辑的一些 package。\napi/\n在这里，我定义了如何通过初始化数据库，服务，HTTP路由器+中间件来连接API，并定义了运行API所需的配置。 我一般会加一个 Start(cfg *Config) 函数，提供给 cmd/api/main.go 调用。\ndb/\n顾名思义，这里是连接、迁移数据库逻辑，我也倾向于将任何关于迁移的文件夹或文件都放在这里。\nutils/\n我会将任何对请求、日志、自定义中间件等提供辅助功能的 pakcage 放在这里。我虽然不太喜欢这个名字，但是我也没找到更适合它的名字了。\nservices/\n这个需要详细解释一下，因为我用特定的方式去组织所有的 service。通常来说，每个 package 都定义了各自服务的功能（基于功能而不是函数进行组织结构）。\nServices 让我们通过一个例子来看看他们是如何组织的。我们要创建一个服务，可以让我们保存并创建文章，他看起来是下面这样：\n... - Services/ - Article/ - store/ - repo.go - transport/ - http.go - article.go - errors.go - models.go 我们将数据的存储和传输逻辑分到了不同的 package，这帮助我们专注于我们的业务逻辑而不需要关心我们应该如何保存数据或者其如何传递给调用方。 此外，当我们想要改变我们的底层存储时，我们只需要定义好存储的 interface，就可以轻松地更换底层存储， 而不需要修改其余的逻辑（ 一个简单的 依赖反转原则 的例子 ）。\nerror.go 和 models.go 比较简单，就不赘述了，让我们看看 article.go 都有什么功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package articles import ( \"context\" ) // Repo defines the DB level interaction of articles type Repo interface { Get(ctx context.Context, id string) (Article, error) Create(ctx context.Context, ar ArticleCreateUpdate) (string, error) } // Service defines the service level contract that other services // outside this package can use to interact with Article resources type Service interface { Get(ctx context.Context, id string) (Article, error) Create(ctx context.Context, ar ArticleCreateUpdate) (Article, error) } type article struct { repo Repo } // New Service instance func New(repo Repo) Service { return \u0026article{repo} } // Get sends the request straight to the repo func (s *article) Get(ctx context.Context, id string) (Article, error) { return s.repo.Get(ctx, id) } // Create passes of the created to the repo and retrieves the newly created record func (s *article) Create(ctx context.Context, ar ArticleCreateUpdate) (Article, error) { id, err := s.repo.Create(ctx, ar) if err != nil { return Article{}, err } return s.repo.Get(ctx, id) } 这里需要注意的是，在调用 New() 创建我们 Article 服务实例的时候，传递了一个 Repo interface。 这个是我们刚刚说的解耦的好处，而且也能帮助我们更好地去做单元测试。 我们可以通过创建一个实现了 Repo interface 的 mock 实例，然后作为 New() 的参数传递给 Article， 这样我们就可以绕过我们的数据库去对我们的逻辑进行单元测试。\n如何暴露服务 设置方法不需要知道每个服务的接入点、如何初始化存储层或者其他的一些事项。 只需要将数据库连接和路由实例传递给 Activate() 方法， 然后 transport package 中的路由注册程序将其路由进行注册，就可以对外提供服务了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package transport import ( \"database/sql\" \"net/http\" \"github.com/gin-gonic/gin\" \"github.com/kott/go-service-example/pkg/services/articles\" \"github.com/kott/go-service-example/pkg/services/articles/store\" ) type handler struct { ArticleService articles.Service } // Activate sets all the services required for articles and registers all the endpoints with the engine. func Activate(router *gin.Engine, db *sql.DB) { articleService := articles.New(store.New(db)) newHandler(router, articleService) } func newHandler(router *gin.Engine, as articles.Service) { h := handler{ ArticleService: as, } router.GET(\"/articles/:id\", h.Get) router.POST(\"/articles/\", h.Create) } func (h *handler) Get(c *gin.Context) {...} func (h *handler) Create(c *gin.Context) {...} 还记得我之前说的 Start() 方法（在 pkg/api 中）吗？ 它是我们启动我们服务和配置的入口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package api import ( \"context\" \"fmt\" \"github.com/gin-gonic/gin\" \"github.com/kott/go-service-example/pkg/db\" articles \"github.com/kott/go-service-example/pkg/services/articles/transport\" \"github.com/kott/go-service-example/pkg/utils/log\" \"github.com/kott/go-service-example/pkg/utils/middleware\" ) // Config defines what the API requires to run type Config struct { DBHost string DBPort int DBUser string DBPassword string DBName string AppHost string AppPort int } // Start initializes the API server, adding the required middleware and dependent services func Start(cfg *Config) { conn, err := db.GetConnection( cfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword, cfg.DBName) if err != nil { log.Error(ctx, \"unable to establish a database connection: %s\", err.Error()) } defer func() { if conn != nil { conn.Close() } }() router := gin.New() router.Use(/* some middleware */) articles.Activate(router, conn) if err := router.Run(fmt.Sprintf(\"%s:%d\", cfg.AppHost, cfg.AppPort)); err != nil { log.Fatal(context.Background(), err.Error()) } } 以上就是全部内容，实际上只是试图去找到一种抽象的方法，以便于让你的程序更易读，而不需要增加你项目的复杂度。\n总结 有许许多多可以组织项目的方式，这个方式是我认为最好的。 根据功能将 service 分开有助于之后进行修改时定义上下文边界和代码导航。 将路由注册、业务逻辑、存储等放到同一个 service 层中，也让我们更关注业务逻辑本身和更容易地进行测试。 不要让简单的事情变复杂！如果您想节约时间，那就一定要这样做。\n我希望能帮助到你，如果你想阅读所有源码，你可以在 Github 下载。\nvia: https://medium.com/@ott.kristian/how-i-structure-services-in-go-19147ad0e6bd\n作者：Kristian Ott 译者：h1z3y3\n本文由 GCTT 原创编译，Go 中文网 荣誉推出\n","description":"","tags":["golang","clean-arch"],"title":"如何在 Go 中组织项目结构","uri":"/posts/how-i-structure-services-in-go/"},{"categories":null,"content":"从 2018 年底到 2021 年初，博客一直搁置，虽然也偶尔写几篇文章，但是都发布在团队的公众号中了， 现在重新开始维护自己的博客，也从 hexo 转移到了 hugo ， 这两个都是非常优秀的静态网站生成工具。\n但是不得不说，使用 hugo 之后感觉易用性以及文件的生成速度都优于我之前使用的 hexo 的版本（说的严谨一些，我也不知道现在如何）。\n同时我还给自己重新挑选了主题，使用的是 hugo-theme-meme ， 并且我还做了一部分自定义， 比如 文章列表页 的样式、字体、还修改了移动端标题过长样式错乱的 bug， 另外还接入了 Gitalk（已经提 pr 并合并）和页面右下角的 Webpusher (没有提交 PR), 不得不说，把自己的博客评论用 Github Issue 来维护的想法也太赞了！\n使用 Github Action 自动发布 hugo 站点 如何使用 hugo 以及 Github Pages 的基本知识我就不再赘述，本文主要给大家讲解如何使用 Github Actions 自动编译你的站点实时发布， 本文可以帮你解决的问题是：如何使用你的 *.github.io 的仓库维护站点的配置 （config.toml）、 使用的主题、或者自己 markdown 格式的原文，而不需要创建新仓库。\n因为我自己一开始也想创建新仓库维护，但是后来查阅了一些相关文档后，发现完全没必要，下面介绍给大家。\n定义 Github Actions 下面是我站点的 Hugo Actions 的配置文件，和原始配置有些小改动， 原始配置文件可以在 这里 找到\n在 hugo 站点的根目录创建 .github/workflows/gh-pages.yml ，并将下面的内容拷贝进去。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 name: github pages # on 是 Actions 的触发条件，这里的配置说明当 master 分支有提交的时候，根据这个配置文件执行 on: push: branches: - master # Set a branch to deploy # jobs 是要执行的任务，我们看到他要执行 deploy jobs: deploy: runs-on: ubuntu-18.04 # 运行环境 steps: # 执行步骤 # checkout 分支 - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod # 安装 hugo - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' # extended: true # 编译站点 - name: Build run: hugo --minify # 创建 CNAME，这个是原始配置中没有的 - uses: \"finnp/create-file-action@master\" env: FILE_NAME: \"./public/CNAME\" FILE_DATA: \"h1z3y3.me\" # 将站点发布到对应分支 - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public Github Actions 更详细的使用可以从 这里 获取。\n设置 hugo 目录的提交仓库为 *.github.io 如果你的 hugo 没在 github 维护，执行:\n\u003e git remote add origin git@github.com:your/your.github.io.git 如果已经在 github 维护了，执行：\n\u003e git remote set-url origin git@github.com:your/your.github.io.git 如果仓库有文件，很可能你需要使用 git push -f origin master 来强制覆盖。\n推送到 Github 之后，现在 Github 的代码就是你 hugo 的根目录，这时候我们的 *.github.io 的站点肯定不工作了，接下来往下看。\nActions 执行 我们切换到 Actions 选项卡，可以看到我们刚才提交的工作流已经执行了， 同时在 Code 选项卡，也帮我们创建好了一个 gh-pages 的分支， 切换之后发现这个 hugo 已经编译好的静态站点。\n修改 Github Page 站点的默认分支 没错，*.github.io 的仓库，允许你自定义你要提供静态站点的分支，默认是 master，可以自定义为其他的\n操作方法：\n进入你的 *.github.io 的仓库，点击项目的 Settings ，并点击左侧的 Pages，在这里你可以自定义一些你站点的配置， 在这里你可以自己选择自己站点要使用的分支以及目录，我们这里切换为 gh-pages 这个分支，并点击保存。\n检查 全部设置好之后，稍等几分钟生效后，通过浏览器访问 your.github.io，就可以正常访问了，之后每次我们文章有更新， 从 master 分支提交之后，Github 就会通过 Actions 帮我们去编译然后发布在 gh-pages 分支，十分方便。\n如果你设置了 CNAME，那么请参照我 Actions 配置，里面有创建 CNAME 文件的步骤，添加到你自己的配置即可。\n","description":"","tags":["hugo"],"title":"使用 Github Actions 自动发布 hugo 站点","uri":"/posts/hugo-auto-deploy-github-with-actions/"},{"categories":null,"content":"Web 反爬指南（或至少让其更难抓取） 提示：这篇文章是我 Stack Overflow 这个问题 回答的扩展， 我把它整理在 Github 因为它实在是太长了，超过了 Stack Overflow 的字数限制（最多 3 万个字，这文章已经超过 4 万字）\n欢迎大家修改、完善还有分享，本文使用 CC-BY-SA 3.0 许可。\n本质上说，防抓的目的在于增加脚本或机器获取你网站内容的难度，而不要影响真实用户的使用或搜索引擎的收录\n不幸的是这挺难的，你需要在防抓和降低真实用户以及搜索引擎的可访问性之间做一下权衡。\n为了防爬（也称为网页抓取、屏幕抓取、网站数据挖掘、网站收割或者网站数据获取）， 了解他们的工作原理很重要，这能防止他们能高效爬取，这个就是这篇文章的主要内容。\n通常情况下，抓取程序的目的是为了获取你网站特定的信息，比如文章内容、搜索结果、产品详情还有网站上艺术家或者相册信息。 他们爬取这些内容用于维护他们自己的网站（甚至通过你的内容赚钱！），或者制作和你网站不一样的前端界面（比如去做移动 APP）， 还有一些可能作为个人研究或分析使用。\n实际上，有特别多的爬虫类型，而且他们的爬取方式都不太相同：\n蜘蛛，比如 Google’s bot 或者网站复制工具 HTtrack，他们访问你的网站， 而且在页面中寻找链接后递归的去爬取以获取页面的数据。有时候他们只用于获取特定数据， 而不会全部爬取，通常结合 HTML 分析器在页面中获取想要的数据。\nShell 脚本，有时候，通用的 Unix 工具也被用来爬取：wget 或者 curl 用于下载页面， 用 Grep （Regex） 去分析获取想要的数据，一般都会写一个 Shell 脚本。 这些都是最简单的爬虫，也是最脆弱的一类爬虫 (Don’t ever try parse HTML with regex !）， 所以是最早发现和防范的爬虫。\nHTML 爬取器和分析器，会基于 Jsoup、Scrapy 还有其他一些工具。 和 shell 脚本基于正则类似，他们能基于特定模式（pattern）分析你的 HTML 结构从而获取想要的数据。\n举个例子：如果你的网站有搜索功能，那这个爬虫可能会模拟提交一个搜索的 HTTP 请求，然后从搜索结果页中获取所有的链接和标题，有时候会构造有成千上百不同的请求，只是为了获取标题和链接而已。这是最常见的一类爬虫。\n屏幕爬取，比如会基于 Selenium 或者 PhantomJS， 他们实际上会通过真实浏览器打开你的网站，因此也会运行你网站的 JavaScript、AJAX 或者其他的， 然后他们从你的页面获取自己想要的文本内容，通常：\n等页面加载完毕， JavaScript 也执行之后，从浏览器获取 HTML 结构，然后用 HTML 分析器去获取想要的数据或者文本。这是常见做法，所以有很多方法可以防止这类 HTML 分析器或爬虫。 获取加载完页面的屏幕截图，然后使用 OCR 分析从截屏中获取想要的数据。这类不常见，而且只有非常想要你网站内容的爬虫才会使用。 基于浏览器的爬去很难处理，他们运行脚本，渲染 HTML，就像真实用户一样访问你的网站。\nWeb爬取服务，比如 ScrapingHub或者 Kimono。 实际上，很多人的工作就是找出如何爬取你的页面获取其中内容并给其他人使用。 他们有时会用大量的代理甚至修改 IP 地址来绕过频率限制和封禁，所以他们是反爬的关键对象。\n毫无疑问，防止专业的爬取服务是非常困难的，但是如果你增加爬取的难度，或者增加他们找出爬取方法的时间，那这些人（或者付钱让他们这样做的人）可能会放弃爬取你的网站。\n把你的网站页面通过 frames 嵌入其他站点， 或者把你的页面嵌入移动 APP。\n虽然没有什么技术含量，但是确实也是个问题，比如移动 APP（Android 和 iOS）可以嵌入你的网站，甚至可以注入一些自定义的 CSS 和 JavaScript，所以可以完全改变你网站的外观，然后只展示想要的信息，比如只展示文章内容或者搜索结果，然后隐藏你网站的 headers、footers 还有广告。\n人肉复制粘贴：人肉复制和粘贴你网站的内容到其他地方。很遗憾，这个没有好的方法加以防范。\n以上不同的爬虫类型有很多相同点，很多爬虫的行为也很相似，即使他们使用了不同的技术或者方案去爬取你的内容。\n这些大多数都是我自己的想法，我在写爬虫时也遇到许多困难，还有一些是来源于网络。\n如何反爬 一些常见的检测和防止爬虫的方法：\n监控你的日志和请求；当发现异常行为时限制访问 周期性的检查你的日志，如果发现有异常活动表明是自动爬取（爬虫），类似某一个相同的 IP 很多相同的行为， 那你就可以阻止或限制访问。\n一些常用的方法：\n频率限制\n只允许用户（或爬虫）在一段时间内访问特定的次数，举个例子，某个 IP 或用户只允许一分钟搜索很少的次数。 这个会减慢爬虫的爬取速度，让他们变得低效。如果次数特别多或者比真实用户多很多，那你也可以显示验证码页面。\n检测异常行为\n如果你能看到异常行为，比如同一个 IP 有很多相同的请求，有些会翻很多页或者访问一些异常的页码，你可以拒绝访问或者在后续的请求中展示验证码。\n不要只通过 IP 检测和限制，也要用其他的用户标识\n如果你做了访问限制或频率限制，不要只简单的根据单个 IP 地址去做；你可以通过其他的标识和方法去识别一个用户或爬虫。 一些可以帮你识别用户/爬虫的标识：\n用户填写表单的速度，还有他们点击按钮的位置 你可以通过 JavaScript 获取很多信息，比如屏幕的大小 / 分辨率，时区，安装的字体等等，你可以用这些去识别用户 携带的 HTTP 头，特别是 User-Agent 举个例子，如果某个 IP 请求了你网站很多次，所有的访问都有相同的 UserAgent 、屏幕尺寸（JavaScript 检测），还有全都使用同样的方式和固定的时间间隔点击同一个按钮，那它大概是一个屏幕爬虫； 你可以临时限制相似的请求（比如 只限制来自那个 IP 特定 User-Agent 和 屏幕尺寸的请求），这样你不会误伤同样使用这个 IP 的真实用户，比如共享网络链接的用户。\n更进一步，当你发现相似的请求，但是来自不同的 IP 地址，表明是分布式爬虫（使用僵尸网络或网络代理的爬虫）。 如果你收到类似大量的请求，但是他们来自不同的 IP 地址，你可以拒绝访问。再强调一下，小心不经意限制了真实用户。\n这种方法对那种运行 JavaScript 的屏幕爬虫比较有效，因为你可以获得他们大量的信息。\nStack Exchange 上关于 Secruity 的相关问题：\nHow to uniquely identify users with the same external IP address? Why do people use IP address bans when IP addresses often change? 关于仅使用 IP 的其他限制\n使用验证码，而不是临时限制访问\n对于频率限制，最简单的方式就是临时限制访问，然而使用验证码会更好，可以看下面关于验证码的部分。\n要求注册和登录 如果可行，要求创建用户才可以查看内容。这个可以很好的遏制爬虫，但很容易遏制真实用户：\n如果你要求必须创建账户和登录，你可以精准的跟踪用户和爬虫的行为。这样的话，你可以很简单就能检测到有爬取行为的账户，然后封禁它。 像频率限制或检测滥用（比如一段时间有大量搜索）就变得简单，你也可以不仅仅通过 IP 去识别爬虫。 为了防止爬虫创建大量的用户，你应该：\n注册时需要提供 email 地址，发送一个验证链接到邮箱，而且这个链接必须被打开才可以激活这个账户。一个邮箱只允许一个账户使用。 在注册或创建用户时，必须通过验证码验证，为了防止创建用户的自动脚本。 要求注册用户对用户和搜索引擎来说不友好；如果你要求必须注册才可以看文章，那用户也可能直接离开。\n阻止来自云服务商和抓取服务的 IP 有时，爬虫会被运行在云服务商，比如 Amazon Web Services 或 Google App Engine，或者其他 VPS。 限制这些来自云服务商的 IP 地址访问你的网站（或出验证码）。 你可以可以直接对来自爬取服务的 IP 地址限制访问。\n类似的，你也可以限制来自代理或 VPN 的 IP 地址，因为很多爬虫会使用它们来防止被检测到。\n但是要知道限制来自代理服务器或 VPN 的 IP，也很容易影响到真实用户。\n当你封禁时不要展示具体错误信息 如果你要封禁或限制访问，你应该确保不要把导致封禁的原因告诉爬虫，他们会根据提示修改自己的爬虫程序。所以下面的这些错误最好不要出现：\n你的 IP 访问太多次了，请重试 出错了，没有 User Agent 相反的，展示一些不包含原因并对用户友好信息会更好，比如下面的信息会更好：\n对不起，有些不对劲。如果问题持续出现，你可以联系 helpdesk@example.com 以获取支持。 如果真实用户看到这个错误页面，这个对真实用户来说也十分友好。在后续访问中，你也可以考虑展示验证码而不是直接封禁， 如果真实用户看到这个错误信息，对于合法用户也会联系你。\n如果有爬虫访问，请使用验证码 验证码（Captcha，“Completely Automated Test to Tell Computers and Humans Apart”)对于防爬十分有效。不幸的是，它也很容易惹恼用户。\n因此，如果你发现疑似爬虫，而且想要阻止它的爬取行为，而不是封禁它以免它是真实用户。你可以考虑显示验证码在它再次允许访问之前。\n使用验证码的注意事项：\n不要造轮子，使用类似 Google 的 reCaptcha的一些服务： 比你自己实现一套验证码服务要简单太多，对于用户来说，也比识别模糊或扭曲的文字更友好（用户一般只需要点击一下）， 而且相对于你自己提供的简单验证码图片，爬虫也更难去破解 不要在 HTML 结构中包含验证码答案：我曾经看到过一个网站在它自己页面上有验证码的答案，（虽然隐藏的很好）所以让验证码根本就没有用。 不要做类似的事情。再强调一次，用像 reCaptcha 的服务，你将不会有类似的问题（如果你正确地使用它） 将你的文字转位图片 你可以在服务端将文字渲染成图片显示，他将防止简单的爬虫去获取文字内容。\n然而，这个对于屏幕阅读器、搜索引擎、性能还有一些其他一些事情都不太好。 这个在某些方面也是不违法的（源于访问性问题，eg. the Americans with Disabilities Act），而且对于一些 OCR 爬虫也能非常简单的规避，所以不要采用这种方式。\n你也可以用 CSS sprites 做类似的事情，但是也有相同的问题。\n不要暴露你完整的数据 如果可以的话，不要让脚本/爬虫能获取你所有的数据。举个例子：你有一个新闻站，有大量的个人文章。 你应该确保文章只能通过你自己网站的搜索到，如果你网站不是到处都有你的文章还有链接，那么确保它们只能被搜索功能访问到。 这意味着如果一个脚本想要获取你网站的所有文章，就必须通过你站点文章中所有可能的短语去进行搜索，从而获取所有的文章列表，但是这个会非常耗时，而且低效，从而让爬虫放弃。\n以下操作会让你完全暴露：\n爬虫/脚本并不想/需要获取所有的数据 你站点文章的链接看起来是这种方式 example.com/article.php?articleId=12345，这样做（或类似的其他做法）会让爬虫很简单的迭代 articleID 就能获取你所有的文章 还有一些其他方式获取所有的文章，比如写一个脚本去递归的爬取你文章中其他文章的链接 搜索一些常用的词比如 “一” 或者 “的” 将会暴露几乎所有的内容。所以这点是要注意的（你可以通过只返回 top 10 或 top 20 来避免这个问题） 你的文章需要被搜索引擎收录 不要暴露你的 API、节点或其他类似的东西 确保你不会暴露你的任何 API，很多时候都是无意间暴露。举个例子，如果你正在使用 AJAX 或 Adobe Flash 的网络请求 或 Java Applet（千万不要用！）来加载你的数据， 从这些网络请求中找到要请求的 API 十分简单，比如可以进行反编译然后在爬虫程序中使用这些接口。确保你混淆了你的 API 并且其他人要用它会非常难破解。\n阻止 HTML 解析器和爬取器 由于 HTML 解析器是通过分析页面特定结构去获取内容，我们可以故意修改这些结构来阻止这类爬虫，甚至从根本上他们获取内容。 下面大多数做法对其他类型爬虫如搜索引擎蜘蛛、屏幕爬虫也有效。\n经常修改你的 HTML 结构 处理 HTML 的爬虫通过分析特定可识别的部分来处理 HTML。举个例子：如果你所有的页面都有 id 为 article-content 的 div结构，然后里面有你的文章内容， 那要获取你站点所有文章内容是十分简单的，只要解析那个 article-content 那个 div 就可以了，然后有这个结构的爬虫就可以把你的文章随便用在什么地方。\n如果你常常修改 HTML 还有你页面的结构， 那这类爬虫就不能一直使用。\n你可以经常修改你 HTML 的 id 和 class，甚至让他能自动改变。所以，如果你的 div.article-content 变成 div.a4c36dda13eaf0，而且每周都会变化， 那么爬虫一开始可能能正常工作，但是一周之后就不能使用了。同时也确保修改你 id/class的长度，这样也可以避免爬虫使用类似 div.[any-14-characters] 来找到想要的 div。 如果无法从标记中找到所需的内容，则抓取工具将通过HTML的结构方式进行查找。所以，如果你的所有文章都有类似的结构，比如每个 div，并且里面通过 h1 放文章的标题，爬虫将基于这个结构获取文章内容。同样的，为了防止这个，你可以在你的 HTML 添加/删除 额外的标记，周期并且随机的做，eg. 添加额外的 div 或 span。对于服务端渲染的程序，这应该不会很难。 注意事项 它的实现、维护和调试都是很复杂困难的 你要注意缓存。特别是你修改你 HTML 元素的 id 或 class 时，也要去修改相应的 CSS 和 JavaScript 文件，这意味着每次修改都要修改这些，而浏览器每次都要重新下载他们。这将导致页面打开慢也会导致服务端负载升高。不过这也不是一个大问题，如果你只是一个星期改变一次。 聪明的爬虫仍然能推断出你文章的位置，比如，页面上大块的文本大概率是文章内容。这个让爬虫从页面找到、获取想要的数据。 Boilerpipe 就是这样做的。 本质上来说，就是确保爬虫从相似页面获取想要的内容变得不那么容易。\n可以参考这个 PHP 的实现：How to prevent crawlers depending on XPath from getting page contents\n基于用户地理位置修改 HTML 这个和前一个类似。如果你根据不同用户的位置/国家（根据 IP 获取）来提供不同的 HTML，这个可能会破坏将站点 HTML 给用户的爬虫。比如，如果有人写了一个移动 APP 来抓取你的站点，一开始可以用，但是对于不同地区的用户就不起作用了，因为他们会获取到不同的 HTML 结构，嵌入式的 HTML 将不不能正常使用。\n经常改变 HTML，并与爬虫斗智斗勇！ 举个例子：你有一个包含搜索功能的网站，example.com/search?query=somesearchquery 的搜索结果是下面的 HTML 结构：\n1 2 3 4 5 6 7 8 \u003cdiv class=\"search-result\"\u003e \u003ch3 class=\"search-result-title\"\u003eStack Overflow has become the world's most popular programming Q \u0026 A website\u003c/h3\u003e \u003cp class=\"search-result-excerpt\"\u003eThe website Stack Overflow has now become the most popular programming Q \u0026 A website, with 10 million questions and many users, which...\u003c/p\u003e \u003ca class\"search-result-link\" href=\"/stories/stack-overflow-has-become-the-most-popular\"\u003eRead more\u003c/a\u003e \u003c/div\u003e (And so on, lots more identically structured divs with search results) 你可以猜到这个非常容易爬取：一个爬虫需要做的就只是访问搜索链接，然后从返回的 HTML 分析想要的数据。除了定期修改上面 HTML 的内容， 你也可以保留旧结构的 id 和 class，然后使用 CSS 进行隐藏，并使用假数据进行填充，从而给爬虫投毒。比如像下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003cdiv class=\"the-real-search-result\"\u003e \u003ch3 class=\"the-real-search-result-title\"\u003eStack Overflow has become the world's most popular programming Q \u0026 A website\u003c/h3\u003e \u003cp class=\"the-real-search-result-excerpt\"\u003eThe website Stack Overflow has now become the most popular programming Q \u0026 A website, with 10 million questions and many users, which...\u003c/p\u003e \u003ca class\"the-real-search-result-link\" href=\"/stories/stack-overflow-has-become-the-most-popular\"\u003eRead more\u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"search-result\" style=\"display:none\"\u003e \u003ch3 class=\"search-result-title\"\u003eVisit example.com now, for all the latest Stack Overflow related news !\u003c/h3\u003e \u003cp class=\"search-result-excerpt\"\u003eEXAMPLE.COM IS SO AWESOME, VISIT NOW! (Real users of your site will never see this, only the scrapers will.)\u003c/p\u003e \u003ca class\"search-result-link\" href=\"http://example.com/\"\u003eVisit Now !\u003c/a\u003e \u003c/div\u003e (More real search results follow) 这意味着基于 id 或 class 获取特定数据的爬虫仍然能继续工作，但是他们将会获取假数据甚至广告，而这些数据真实用户是看不到的，因为他们被 CSS 隐藏了。\n与爬虫斗智斗勇：在页面插入假的、不可见的蜜罐数据 对上个例子进行补充，你可以在你的 HTML 里面增加不可见的蜜罐数据来抓住爬虫。下面的例子来补充之前说的搜索结果：\n1 2 3 4 5 6 7 8 9 \u003cdiv class=\"search-result\" style=\"display:none\"\u003e \u003ch3 class=\"search-result-title\"\u003eThis search result is here to prevent scraping\u003c/h3\u003e \u003cp class=\"search-result-excerpt\"\u003eIf you're a human and see this, please ignore it. If you're a scraper, please click the link below :-) Note that clicking the link below will block access to this site for 24 hours.\u003c/p\u003e \u003ca class\"search-result-link\" href=\"/scrapertrap/scrapertrap.php\"\u003eI'm a scraper !\u003c/a\u003e \u003c/div\u003e (The actual, real, search results follow.) 一个来获取所有内容的爬虫将会被找到，就像获取其他结果一样，访问链接，查找想要的内容。一个真人将不会看到（因为使用 CSS 隐藏），而且更不会访问这个链接。而正规或者期望的蜘蛛比如谷歌的蜘蛛将不会访问这个链接，因为你可以将 /scrapertrap/ 加入你的 robots.txt 中（不要忘记增加）\n你可以让你的 scrapertrap.php 做一些比如限制这个 IP 访问的事情，或者强制这个 IP 之后的请求出验证码。\n不要忘记在你的 robots.txt 中添加禁止访问 /scrapertrap/ 的规则避免所有的搜索引擎不会中招 你可以/应该和上个经常更换 HTML 结构的例子一起使用 也要经常修改它，因为爬虫可能会周期性的了解并不去访问它。修改蜜罐 URL 和文本。 同时要考虑使用 id 属性或外部的 CSS 来取代内联的 CSS，要不然爬虫将会学会防止爬取所有包含隐藏属性 style 的节点。 并且只是偶尔启用它， 这样爬虫一开始正常工作，但是过段时间就不起作用。这个同样也适用于上个例子。 要注意可能会有恶意的人在论坛发布像 [img]http://yoursite.com/scrapertrap/scrapertrap.php[img]， 然后当正常用户访问轮然然后点击到你的蜜罐链接。所以上个注意事项中经常更换你的蜜罐链接是非常重要的，当然你也可以检查 Referer。 当识别为爬虫时，提供假的或无用的数据 如果你确定某个访问是爬虫，你可以提供假的或者无用的数据；这将破坏爬虫从你网站获取的数据。 你还应该把它和真实数据进行混淆，这样爬虫就不知道他们获取的到底是真的还是假的数据。\n举个例子：如果你有一个新闻站，你检测到了一个爬虫，不要去直接封禁它， 而是提供假的或者 随机生成 的文章，那爬虫获取的数据将会被破坏。如果你将假数据和真实的数据进行混淆，那爬虫很难获取到他们想要的真实文章。\n不要接受没有 UserAgent 的请求 很多懒惰的程序员不会在他们的爬虫发请求时带上 UserAgent，而所有的浏览器包括搜索引擎蜘蛛都会携带。\n如果请求你时没有携带 UserAgent header 头，你可以展示验证码，或者直接封禁或者限制访问（或者像上面说的提供假数据或者其他的）\n这个非常简单去避免，但是作为一种针对书写不当的爬虫，是值得去做的。\n不要接受 UserAgent 是通用爬虫或在爬虫黑名单的请求 很多情况下，爬虫将会使用真实浏览器或搜索引擎爬虫绝对不会使用的 UserAgent，比如：\n“Mozilla” （就只有这个，我曾经看到过一些爬虫的问题用这个，但真实浏览器绝对不会用） “Java 1.7.43_u43” （Java 的 HttpUrlConnection 的默认 UserAgent） “BIZCO EasyScraping Studio 2.0” “wget”, “curl”, “libcurl”,.. （基础爬虫有时候会用 Wget 和 cURL） 如果你发现一些爬虫使用真实浏览器或合法蜘蛛绝对不会使用的 UserAgent，你可以将其添加到你的黑名单中。\n检查 Referer header 头 对上一章节的补充，你也可以检查 Referer （是的，它是 Referer，而不是 Referrer）， 一些懒惰的爬虫可能不会携带的这个，或者只是每次都携带一样的（有时候是 “google.com”）。 举个例子，如果用户是从站内搜索结果页点击进入文章详情的，那要检查 Referer 这个 header 头是否存在还要看搜索结果页的打点。\n注意：\n真实浏览器并不总是携带 Referer； 很容易被避免 还是，作为一种防止简单爬虫的方法，也值得去实现。\n如果不请求资源（CSS，images），它可能不是真实浏览器 一个真实浏览器（通常）会请求和下载资源比如 CSS 和 图片。HTML 解析器和爬取器可能只关心特定的页面和内容。\n你可以基于访问你资源的日志，如果你看到很多请求只请求 HTML，那它可能就是爬虫。\n注意搜索引擎蜘蛛、旧的移动设备、屏幕阅读器和设置错误的设备可能也不会请求资源。\n要求使用 Cookie；使用它们来跟踪用户和爬虫行为 访问你网站时，你可以要求 cookie 必须开启。这个能识别没有经验和爬虫新手，然而爬虫要携带 Cookie 也十分简单。如果你要求开启 Cookie，你能使用它们来追踪用户和爬虫的行为，然后基于此来实现频率限制、封禁、或者显示验证码而不仅仅依赖 IP 地址。\n举个例子： 当用户进行搜索时，设置一个唯一的 Cookie。当搜索结果加载出来之后，验证这个 Cookie。 如果一个用户打开了所有的搜索结果（可以从 Cookie 中得知），那很可能就是爬虫\n使用 Cookie 可能是低效的，因为爬虫也可以携带 Cookie 发送请求，也可以根据需要丢弃。 如果你的网站只能在开启 Cookie 时使用，你也不能给关闭 Cookie 的用户提供服务。\n要注意如果你使用 JavaScript 去设置和检测 Cookie，你能封禁那些没有运行 JavaScript 的爬虫，因为它们没办法获取和发送 Cookie。\n使用 JavaScript 和 AJAX 加载内容 你可以在页面加载完成之后，使用 JavaScript + AJAX 来加载你的内容。这个对于那些没有运行 JavaScript 的 HTML 分析器来说将无法取得数据。 这个对于没有经验或者新手程序员写的爬虫非常有效。\n注意：\n使用 JavaScript 加载内容将会降低用户体验和性能； 搜索引擎也不会运行 JavaScript，因此不会对你的内容进行收录。这对于搜索结果来说可能不是问题，但是要注意其他页面，比如文章页面； 写爬虫的程序员获取到加载内容的 API 后可以直接使用它 混淆你的数据和网络请求，不要让其直接通过脚本就能获取 如果你用 Ajax 和 JavaScript 加载你的数据，在传输的时候要混淆一下。比如，你可以在服务器端 encode 你的数据（比如简单的使用 base64 或 负载一些的多次混淆、位偏移或者是进行加密）， 然后在客户端在 Ajax 获取数据之后再进行 decode。这意味着如果有人要抓包获取你的请求就不能直接看到你页面如何加载数据，而且那些人也不能直接通过 API 获得你的数据，如果想要获取数据，就必须要去解密你的算法。\n如果你用 Ajax 加载数据，那你应该强制在页面加载之后才可以获取，比如要求获取数据必须包含 session 信息，这些你可以在页面加载的时候嵌入到 JavaScript 或 HTML 中\n你也可以直接吧混淆的数据嵌入到 HTML 中，然后用 JavaScript 去解密然后再显示它们，这样的话，你就不需要再使用 Ajax 去做额外的请求。 这样做可以让那些不运行 JavaScript 的 HTML 解析器更难获取你的数据，他们必须要反解你的 JavaScript（没错，JavaScript 也要做混淆）\n你应该经常更换混淆方法以免爬虫找出方法揭秘它\n下面是一些这个方式的缺点：\n实现、维护和调试都非常麻烦 虽然让爬虫变得不容易抓取，但是对于截屏类的爬虫来说，它们实际上会运行 JavaScript，所以能获取到数据 （不过很多简单的 HTML 解释器不会运行 JavaScript） 如果真实用户禁用了 JavaScript，那你的网站将不能正常显示 性能和页面加载速度会受到影响 其他非技术做法 你的服务器供应商可能提供搜索引擎蜘蛛或爬虫的防御： 比如，CloudFlare 提供反蜘蛛和反爬虫的防御，你只需要直接启用它就可以了，另外 AWS 也提供类似服务。而且 Apache 的 mod_evasive 模块也能让你很轻松地实现频率限制。\n直接告诉别人不要抓取，会有人尊重而且停止抓取 你应该直接告诉人们不要抓取你的网站，比如，在你的服务条款中表明。有些人确实会尊重它，而且不在你允许的情况下不会再去抓取数据。\n寻求律师的援助 律师们知道如何处理侵犯版权的事情，而且他们可以发送律师函。 DMCA（译者注：Digital Millennium Copyright Act，数字千年版权法案，是一个美国版权法律） 也能提供援助。\n直接提供 API 获取你的数据 这看起来适得其反，但是你可以要求标明来源并包含返回你站点的链接。甚至也可以售卖你的 API 而赚取费用。\n还有就是，Stack Exchange 提供了 API，但是必须要标明来源。\n其他补充 要在用户体验和反爬之间做权衡：你做的每个举措都有可能在某种程度上影响用户体验，所以你必须要权衡和妥协；\n不要忘你的移动站点和 APP：如果你的站点有移动版，要小心爬虫也可以通过它爬取你的数据。或者说你有移动 APP，他们也可以截屏分析， 或者可以抓取你的网络请求去直接找到你的 RESTful 的 API 直接使用；\n如果你对一些特定浏览器提供了特定的版本，比如对很老的 IE 版本提供网站的阉割版，不要忘记爬虫也可以直接爬取它；\n选出集中最适合你的策略结合起来使用，而不是只用一种；\n爬虫可以抓取其他爬虫：如果有个网站显示的内容都是从你网站爬取的，那另外一个爬虫也可以直接爬取那个网站。\n有哪些最有效的方法 ？ 以我自己写和帮忙别人写爬虫的经验，我认为最有效的方法是：\n经常修改 HTML 的结构\n蜜罐和假数据\n使用混淆的 JavaScript、Ajax 还有 Cookie\n频率限制、爬虫检测和请求封禁\n扩展阅读：\n维基百科关于 Web 爬虫的文章 ， 其中提到了很多 Web 爬虫的相关技术和爬虫类型，看完如何进行 web 爬取的一些信息，也不要忘记看一看爬取的合法性。 最后祝你在保护你网站的内容坎坷路上一路顺风…\nvia: https://github.com/JonasCz/How-To-Prevent-Scraping\n作者：JonasCz 译者：h1z3y3\n","description":"","tags":["反爬"],"title":"Web 反爬指南（或至少让其更难抓取）","uri":"/posts/how-to-prevent-scraping/"},{"categories":null,"content":"Golang 逃逸分析 Golang 的垃圾回收机制可以进行自动内存管理让我们的代码更简洁，同时发生内存泄漏的可能性更小。 然而，GC 会定期停止并收集未使用的对象，因此还是会增加程序的开销。 Go 的编译器十分聪明，比如决定变量需要分配在堆上还是栈上，和分配在堆上不同的是在栈上的变量在声明它的函数结束之后就会被回收。 那对于 GC 来说，分配在栈上的变量不会带来额外的开销，在函数 return 之后，函数的整个调用栈都会被销毁。\n那到底变量应该分配在堆上还是栈上，Golang 如何决定呢，这就要说到 Golang 的逃逸分析。\n判断逃逸的基本规则是如果一个函数的返回值是本函数内声明的某个变量的引用，那么就称这个变量从这个函数中逃逸了。 作为本函数的返回值，它还能被函数外的其他程序修改，所以它必须分配在堆上，而不能分配在那个函数的栈上。\n因此，如果在编译过程中，能对变量的逃逸情况作分析，可以提高我们程序的性能。 首先最大的好处就是能够减少垃圾回收的压力，没有逃逸的变量分配在栈上，函数返回就能直接回收资源； 其次逃逸分析完之后，我们能确定哪些变量其实可以分配在栈上，栈的分配比堆快，性能更好； 还有可以进行同步消除，如果定义变量的函数有同步锁，但是运行时却只有一个线程访问，那此时逃逸分析后的机器码，会去掉同步锁运行。\n开启 Go 编译时的逃逸分析日志 在编译时，添加 -gcflags '-m' 参数即可查看go编译过程中详细的逃逸分析日志。 但为了不让 Go 编译时自动内联函数，会加上 -l 参数，最终为 -gcflags '-m -l'。\nExample 0:\npackage main type S struct {} func main() { var x S _ = identity(x) } func identity(x S) S { return x } Output:\n$ go run -gcflags '-m -l' escape.go $ $ 可以看到没有任何输出，我们知道 Go 在调用函数的时候，会采用按值传递，那么在 main 函数中声明的 x， 会被拷贝到 identity() 函数的栈中。通常，没有引用的代码总是使用栈分配，因此没有逃逸分析日志的输出。\n那如果稍微改一下代码：\nExample 1:\npackage main type S struct {} func main() { var x S y := \u0026x _ = *identity(y) } func identity(z *S) *S { return z } Output:\n$ go run -gcflags '-m -l' escape.go # command-line-arguments ./escape.go:11:22: leaking param: z to result ~r1 level=0 ./escape.go:7:8: main \u0026x does not escape 第一行是 z 变量是流经某个函数的意思，仅作为函数的输入，并且直接返回， 在 identity() 中也没有使用到 z 的引用，所以变量没有逃逸。\n第二行，x 在 main() 函数中声明，所以是在 main() 函数中的栈中的，也没有逃逸。\nExample 2:\npackage main type S struct {} func main() { var x S _ = *ref(x) } func ref(z S) *S { return \u0026z } Output:\n$ go run -gcflags '-m -l' escape.go # command-line-arguments ./escape.go:11:10: \u0026z escapes to heap ./escape.go:10:16: moved to heap: z 可以看到发生了逃逸。 ref() 的参数 z 是通过值传递的，所以 z 是 main() 函数中 x 的一个值拷贝， 而 ref() 返回了 z 的引用，所以 z 不能放在ref()的栈中， 实际上被分配到了堆上。\n实际上，我们发现 main() 函数中没有直接使用 ref() 返回的引用，这种情况其实 z 可以分配到ref()的栈上， 但是Go的逃逸分析并没有复杂到来识别出这种情况，它只看输入还有返回的变量的流程。 值得注意的是，如果我们没有加 -l 参数，其实 ref() 会被编译器内联到 main() 使用。\n如果引用被赋值到结构体的成员呢？\nExample 3:\npackage main type S struct { M *int } func main() { var i int refStruct(i) } func refStruct(y int) (z S) { z.M = \u0026y return z } Output:\n$ go run -gcflags '-m -l' escape.go # command-line-arguments ./escape.go:13:9: \u0026y escapes to heap ./escape.go:12:26: moved to heap: y 可以发现，即使这个引用是结构体的一个成员，Go的逃逸分析可以跟踪引用的。 当结构体 refStruct 返回时，y 一定是从 refStruct() 中逃逸的。\n可以再和下面例子比较一下：\nExample 4:\npackage main type S struct { M *int } func main() { var i int refStruct(\u0026i) } func refStruct(y *int) (z S) { z.M = y return z } Output:\n$ go run -gcflags '-m -l' escape.go # command-line-arguments ./escape.go:12:27: leaking param: y to result z level=0 ./escape.go:9:13: main \u0026i does not escape 那这个 y 没有逃逸的原因是，main() 中带着 i 的引用调用了 refStruct() 并直接返回了， 从来没有超过 main() 函数的调用栈，原因和 Example 1 实际上是一样的。\n另外要说明一点，Example 4 要比 Example 3 更高效：\n在 Example 3 中，i 必须在main() 的栈中申请一块栈空间，经过refStruct()后，y还要在堆上再申请一块空间； 而在 Example 4 中，实际上只有i申请了一次空间，然后它的引用经过了 refStruct() 而已。\n一个更复杂的例子：\nExample 5:\npackage main type S struct { M *int } func main() { var x S var i int ref(\u0026i, \u0026x) } func ref(y *int, z *S) { z.M = y } Output:\n$ go run -gcflags '-m -l' escape.go # command-line-arguments ./escape.go:13:21: leaking param: y ./escape.go:13:21: ref z does not escape ./escape.go:10:7: \u0026i escapes to heap ./escape.go:9:7: moved to heap: i ./escape.go:10:11: main \u0026x does not escape y 和 z 没有逃逸很好理解，但问题在于 y 还被赋值到函数 ref() 的输入 z 的成员了， 而Go的逃逸分析不能跟踪变量之间的关系，不知道 i 变成了 x 的一个成员， 分析结果说 i 是逃逸的，但本质上 i是没逃逸的， 这个时候Go的逃逸分析实际上是有问题的。\n这里还有好多因为Go逃逸分析的不足而导致被分配到堆的变态例子： https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview\n其实说这么多其实就是为了说明如果想要减少垃圾回收的时间，提高程序性能， 那就要尽量避免在堆上分配空间，之后在写程序的时候可以多考虑一下这方面的问题。;)\n参考 《Golang escape analysis》\n《Go Escape Analysis Flaws》\n","description":"","tags":["Golang"],"title":"Golang 逃逸分析","uri":"/posts/golang-escape-analysis/"},{"categories":null,"content":"深入剖析 Golang Pprof 标签 Polar Signal 提供的持续分析工具可以和任何格式的 pprof 配置适配，Go 深度集成了 pprof 甚至支持了它的标签特性。然而，自从我们发布了我们持续分析的产品之后，我们收到了很多工程师的反馈，发现许多工程师不知道如何去分析，或者不知道分析能给他们带来什么好处。这篇文章主要剖析 pprof 标签，并会结合一些 Go 的示例代码去分析。\n基础 pprof 标签只支持 Go 的 CPU 分析器。Go 的分析器是抽样分析，这意味着它只会根据特定的频率（默认是 1 秒钟 100 次）去获取执行中函数的调用栈并记录。简单来说，开发者如果使用标签，在分析器取样时就可以将函数的调用栈进行区分，然后只聚合有相同标签的函数调用栈。\nGo 在 runtime/pprof 包中已经支持了标签检测，可以使用 pprof.Do 函数非常方便的使用。\n1 2 3 pprof.Do(ctx, pprof.Labels(\"label-key\", \"label-value\"), func(ctx context.Context) { // execute labeled code }) 进阶 为了进行演示如何使用 pprof 标签，我们创建了一个包含许多示例的仓库，示例仓库会作为这篇文章内容的说明。仓库地址：https://github.com/polarsignals/pprof-labels-example\n示例代码的 main.go 通过将 tanant 传递给 iterate 函数实现了大量的 for 循环，其中tanant1 做了 10 亿次循环，而 tanant2 做了 1 亿次循环，同时会记录 CPU 的分析日志并将其写入 ./cpuprofile.pb.gz。\n为了演示如何在 pprof 的分析日志中展示 pprof 标签，用 printprofile.go 来打印每次抽样函数调用栈以及样本值，还有收集到样本的标签。\n如果我们注释掉 pprof.Do 的这部分，我们将无法进行标签检测，运行 printprofile.go 代码，让我们看看没有标签的抽样分析日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 runtime.main main.main main.iteratePerTenant main.iterate 2540000000 --- runtime.main main.main main.iteratePerTenant main.iterate 250000000 --- Total: 2.79s CPU 分析数据的单位是 纳秒，所以这些抽样总共花费时间是 2.79 秒（2540000000ns + 250000000ns = 2790000000ns = 2.79s）。\n同样的，现在当每次调用 iterate 时添加标签，用 pprof 分析，这些数据看起来就不太一样，打印出带有标签的抽样分析日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 10000000 --- runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 2540000000 map[tenant:[tenant1]] --- runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 10000000 map[tenant:[tenant1]] --- runtime.main main.main main.iteratePerTenant runtime/pprof.Do main.iteratePerTenant.func1 main.iterate 260000000 map[tenant:[tenant2]] --- Total: 2.82s 将所有抽样加起来总共花费了 2.82 秒，然而，因为调用 iterate 时，我们添加了标签，所以我们能在结果中区分哪个 tanant 导致了更多的 CPU 占用。现在我们可以说 tenant1 花费了总时间 2.82 秒中的 2.55 秒（2540000000ns + 10000000ns = 2550000000ns = 2.55s）。\n让我们看看抽样的原始日志（还有它们的元数据），去更深入理解一下它们的格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 $ protoc --decode perftools.profiles.Profile --proto_path ~/src/github.com/google/pprof/proto profile.proto \u003c cpuprofile.pb | grep -A12 \"sample {\" sample { location_id: 1 location_id: 2 location_id: 3 location_id: 4 location_id: 5 value: 1 value: 10000000 } sample { location_id: 1 location_id: 2 location_id: 3 location_id: 4 location_id: 5 value: 254 value: 2540000000 label { key: 14 str: 15 } } sample { location_id: 6 location_id: 2 location_id: 3 location_id: 4 location_id: 5 value: 1 value: 10000000 label { key: 14 str: 15 } } sample { location_id: 1 location_id: 2 location_id: 3 location_id: 7 location_id: 5 value: 26 value: 260000000 label { key: 14 str: 16 } } 我们可以看到每个抽样都由许多 ID 组成，这些 ID 指向它们在分析日志 location 数组中的位置，除了这些 ID 还有几个值。仔细看下 printprofile.go 程序，你会发现它使用了每个抽样的最后一个抽样 value。 实际上，Go 的 CPU 分析器会记录两个 value，第一个代表这个调用栈在一次分析区间被记录样本的数量，第二个代表它花费了多少纳秒。pprof 的定义描述当没设置 default_sample_type 时（在 Go 的 CPU 配置中设置），就使用所有 value 中的最后一个，因此我们使用的是代表纳秒的 value 而不是样本数的 value。最后，我们可以打印出标签，它是 pprof 定义的一个以字符串组成的字典。\n最后，因为用标签去区分数据，我们可以让可视化界面更直观。\n你可以在 Polar Signals 网站这里去更详细的了解上面的这次分析：https://share.polarsignals.com/2063c5c/\n结论 pprof 标签是帮助我们理解不同执行路径非常有用的方法，许多人喜欢在多租户系统中使用它们，目的就是为了能够定位在他们系统中出现的由某一个租户导致的性能问题。就像开头说的，只需要调用 pprof.Do 就可以了。\nPolar Signals 提供的持续分析工具也支持了 pprof 标签的可视化界面和报告，如果你想参与个人体验版请点击：申请资格\nvia: https://www.polarsignals.com/blog/posts/2021/04/13/demystifying-pprof-labels-with-go/\n作者：Frederic Branczyk 译者：h1z3y3 校对：校对者ID\n本文由 GCTT 原创编译，Go 中文网 荣誉推出\n","description":"","tags":["Golang","GCTT"],"title":"深入剖析 Golang Pprof 标签","uri":"/posts/demysitifying-pprof-labels-with-go/"},{"categories":null,"content":"介绍 在 非阻塞 I/O 超简明介绍 中， 我们已经讨论过现代 Web 服务器可以处理大量并发请求，这得益于现代操作系统内核内置的事件通知机制。 受 Linux epoll [ 文档 ] 启发， FreeBSD 发明了 kqueue [ 论文 , 文档 ]\n这篇文章我们将仔细研究下 kqueue，我们会用 Go 实现一个基于 kqueue event loop 的 TCP server， 你可以在 Github 上找到 源代码 。 要运行代码必须使用和 FreeBSD 兼容的操作系统，比如 macOS。\n注意 kqueue 不仅能处理 socket event，而且还能处理文件描述符 event、信号、异步 I/O event、子进程状态改变 event、 定时器以及用户自定义 event。它确实通用和强大。\n我们这篇文章主要分为一下几部分讲解。 首先，我们会在先从理论出发设计我们的 TCP Server。 然后，我们会去实现它的必要的模块。 最后我们会对整个过程进行总结以及思考。\n设计 我们 TCP Server 大概有以下几部分： 一个监听 TCP 的 socket、 接收客户端连接的 socket、 一个内核事件队列（kqueue）， 还有一个事件循环机制来轮询这个队列。 下面这个图描述了接收连接的场景。\n当客户端想要连接服务端，一个连接请求将会被放到 TCP 连接队列中， 而内核会将一个新的事件放到 kqueue 中。 这个事件将会在事件循环时被处理，事件循环会接受请求，并创建一个新的客户端连接。 下面这个图描述了新创建的 socket 如何从客户端读取请求。\n客户端写数据到新创建的 socket，内核会将一个新 event 放到 kqueue 中，表示在这个 socket 中有等待读取的数据。 事件循环将轮询到这个事件，并从 socket 读取数据。 注意只有一个 socket 监听连接，而我们将为每一个客户端连接创建新的 socket。\n下文要讨论实现细节，可以大概按照下面的步骤实现我们的设计。\n1 创建，绑定以及监听新的 socket 2 创建 kqueue 3 订阅 socket event 4 循环队列获取 event 并处理它们\n实现 为了避免单个文件有大量系统调用，我们拆分成几个不同模块：\n一个 socket 模块来处理所有管理 socket 的相关功能， 一个 kqueue 模块来处理事件循环， 最后 main 模块用来整合所有模块并启动我们的 TCP server。 我们下面从 socket 模块开始。\n定义 Socket 首先，让我们创建一个 socket 结构体。类 Unix 操作系统，比如 FreeBSD，会把 socket 作为文件。 为了用 Go 实现 socket，我们需要了解 文件描述符。 所以我们可以创建一个类似下面带有文件描述符的结构体。\n1 2 3 4 type Socket struct { FileDescriptor int } 我们期望我们的 socket 可以应对不同的场景，比如：读、写 socket 数据，以及关闭 socket。 在 Go 中，要支持这些操作，需要实现通用的 interface，比如 io.Reader，io.Writer，还有 io.Closer\n首先，实现 io.Reader 这个接口，他会调用 read() 系统函数。 这个函数会返回读到字节的数量，以及进行读操作时可能发生的错误。\n1 2 3 4 5 6 7 8 9 10 11 12 func (socket Socket) Read(bytes []byte) (int, error) { if len(bytes) == 0 { return 0, nil } numBytesRead, err := syscall.Read(socket.FileDescriptor, bytes) if err != nil { numBytesRead = 0 } return numBytesRead, err } 类似的，我们通过调用 write() 来实现 io.Writer 接口。\n1 2 3 4 5 6 7 8 func (socket Socket) Write(bytes []byte) (int, error) { numBytesWritten, err := syscall.Write(socket.FileDescriptor, bytes) if err != nil { numBytesWritten = 0 } return numBytesWritten, err } 最后关闭 socket 可以调用 close() ，并传入 socket 对应的文件描述符。\n1 2 3 func (socket *Socket) Close() error { return syscall.Close(socket.FileDescriptor) } 为了稍后能打印一些有用的错误和日志，我们也需要实现 fmt.Stringer 接口。 我们通过不同的文件描述符来区分不同的 socket。\n1 2 3 func (socket *Socket) String() string { return strconv.Itoa(socket.FileDescriptor) } 监听一个 Socket 定义好 Socket 之后，我们需要初始化它，并让它一个监听特定 IP 和 端口的。 监听一个 socket 也可以通过一些系统函数来实现。 现在先整体看一下我们实现的 Listen() 方法，然后再一步步进行分析。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func Listen(ip string, port int) (*Socket, error) { socket := \u0026Socket{} socketFileDescriptor, err := syscall.Socket(syscall.AF_INET, syscall.SOCK_STREAM, 0) if err != nil { return nil, fmt.Errorf(\"failed to create socket (%v)\", err) } socket.FileDescriptor = socketFileDescriptor socketAddress := \u0026syscall.SockaddrInet4{Port: port} copy(socketAddress.Addr[:], net.ParseIP(ip)) if err = syscall.Bind(socket.FileDescriptor, socketAddress); err != nil { return nil, fmt.Errorf(\"failed to bind socket (%v)\", err) } if err = syscall.Listen(socket.FileDescriptor, syscall.SOMAXCONN); err != nil { return nil, fmt.Errorf(\"failed to listen on socket (%v)\", err) } return socket, nil } 首先调用了 socket() 函数， 这将会创建通信的接入点，并返回描述符编号。 它需要 3 个参数：\n地址类型：我们用的是 AF_INET (IPv4) socket 类型：我们用 SOCKET_STREAM，代表基于字节流连续、可靠的双向连接。 协议类型：0 在 SOCKET_STREAM 类型下代表的是 TCP。 然后，我们调用了 bind() 方法来指定新创建 socket 的协议地址。 bind() 方法的第一个参数是文件描述符，第二个参数是包含地址信息的结构体指针。 我们在这里使用了 Go 预定义的 SockaddrInet4 结构体，并指定要绑定的 IP 地址和端口。\n最后，我们调用了 listen() 方法，这样我们就能等待接收连接了。 它的第二个参数是连接请求队列的最大长度。 我们使用了内核参数 SOMAXCONN ，在我的 Mac 上默认是 128。 你可以通过执行 sysctl kern.ipc.somaxconn 来获取这个值。\n定义事件循环 同样的，我们将定义一个结构体来表示 kqueue 的事件循环。 我们必须要保存 kqueue 的文件描述符以及 socket 的文件描述符, 我们当然也能将我们前面定义的 socket 对象作为指针来替代 SocketFileDescriptor。\n1 2 3 4 5 type EventLoop struct { KqueueFileDescriptor int SocketFileDescriptor int } 接下来，我们需要一个函数根据我们提供的 socket 创建一个事件循环。 和之前一样，我们需要用一系列系统函数去创建 Kqueue。 我们还是先看下整个函数，然后再一步步拆解来看。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 func NewEventLoop(s *socket.Socket) (*EventLoop, error) { kQueue, err := syscall.Kqueue() if err != nil { return nil, fmt.Errorf(\"failed to create kqueue file descriptor (%v)\", err) } changeEvent := syscall.Kevent_t{ Ident: uint64(s.FileDescriptor), Filter: syscall.EVFILT_READ, Flags: syscall.EV_ADD | syscall.EV_ENABLE, Fflags: 0, Data: 0, Udata: nil, } changeEventRegistered, err := syscall.Kevent( kQueue, []syscall.Kevent_t{changeEvent}, nil, nil ) if err != nil || changeEventRegistered == -1 { return nil, fmt.Errorf(\"failed to register change event (%v)\", err) } return \u0026EventLoop{ KqueueFileDescriptor: kQueue, SocketFileDescriptor: s.FileDescriptor }, nil } 第一个系统函数 kqueue() 创建了一个新的内核事件队列，并且返回了它的文件描述符。 我们等会调用 kevent() 的时候会用到这个队列。 kevent() 有两个功能，订阅新事件和轮询队列。\n我们的例子是要订阅传入连接的事件， 可以通过传递 kevent 结构体（在 Go 中，用 Kevent_t 表示）给 kevent() 这个系统函数来实现订阅。 Kevent_t 需要包含以下信息：\nIdent 的文件描述符：值是我们 socket 的文件描述符 处理事件的 Filter：设置为 EVFILT_READ，当和监听 socket 一起用时，它代表我们只关心传入连接的事件。 代表对这个事件要执行操作的 Flag：在我们例子中，我们想要添加（EV_ADD）事件到 kqueue，比如说订阅事件，同时要启用（EV_ENABLE）它。Flag 可以使用 或 这个位操作进行结合。 其他的几个参数我们就不需要了，创建好这个事件之后，要把它用一个数组包裹，并传递给 kevent() 这个系统函数。 最后，我们返回这个等待被轮询的事件循环。接下来让我们实现轮询的函数。\n事件循环轮询 事件循环是一个简单的 for 循环，可以轮询新的内核事件并进行处理。 之前使用系统函数 kevent() 时，订阅轮询就已经完成了，但是现在我们又传递一个空的事件数组给它， 目的是当有新的事件时，新的事件会填充到这个数组。\n然后我们就可以一个个循环这些事件并处理它们了。 新的客户端连接会被转换成客户端 socket，所以我们可以从客户端读取或写入数据。 现在让我们看下代码如何循环不同的事件类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 func (eventLoop *EventLoop) Handle(handler Handler) { for { newEvents := make([]syscall.Kevent_t, 10) numNewEvents, err := syscall.Kevent( eventLoop.KqueueFileDescriptor, nil, newEvents, nil ) if err != nil { continue } for i := 0; i \u003c numNewEvents; i++ { currentEvent := newEvents[i] eventFileDescriptor := int(currentEvent.Ident) if currentEvent.Flags\u0026syscall.EV_EOF != 0 { // client closing connection syscall.Close(eventFileDescriptor) } else if eventFileDescriptor == eventLoop.SocketFileDescriptor { // new incoming connection socketConnection, _, err := syscall.Accept(eventFileDescriptor) if err != nil { continue } socketEvent := syscall.Kevent_t{ Ident: uint64(socketConnection), Filter: syscall.EVFILT_READ, Flags: syscall.EV_ADD, Fflags: 0, Data: 0, Udata: nil, } socketEventRegistered, err := syscall.Kevent( eventLoop.KqueueFileDescriptor, []syscall.Kevent_t{socketEvent}, nil, nil ) if err != nil || socketEventRegistered == -1 { continue } } else if currentEvent.Filter\u0026syscall.EVFILT_READ != 0 { // data available -\u003e forward to handler handler(\u0026socket.Socket{ FileDescriptor: int(eventFileDescriptor) }) } // ignore all other events } } } 第一种情况，我们要处理 EV_EOF 事件，代表客户端想要关闭它的连接的事件。这种情况我们简单的关闭了对应 socket 的文件描述符。\n第二种情况代表我们的监听 socket 有连接请求。 我们可以使用系统函数 accept() 从 TCP 连接请求队列中获取连接请求， 它会为监听 socket 创建一个新的客户端 socket 和新的文件描述符。 我们为这个新创建的 socket 订阅一个新的 EVFILT_READ 事件。 在新创建的客户端 socket 中，无论什么时候有可以读取的数据，就会有 EVFILT_READ 事件发生。\n第三种情况就是处理刚提到的 EVFILT_READ 事件，这些事件有客户端 socket 的文件描述符， 我们将其封装在 Socket 对象中并传递给要处理它的方法。\n要注意我们省略一些错误然后使用了简单的 continue 继续执行循环。现在事件循环函数也写好了，让我们将所有的逻辑封装在 main 函数中并执行。\nmain 函数 因为之前已经定义好了 socket 和 kqueue 模块，我们现在可以非常容易地实现服务器。 我们首先创建一个监听特定 IP 地址和端口的 socket，然后基于它创建一个新的事件循环， 最后我们定义处理输出的函数，来开启我们的事件循环。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 func main() { s, err := socket.Listen(\"127.0.0.1\", 8080) if err != nil { log.Println(\"Failed to create Socket:\", err) os.Exit(1) } eventLoop, err := kqueue.NewEventLoop(s) if err != nil { log.Println(\"Failed to create event loop:\", err) os.Exit(1) } log.Println(\"Server started. Waiting for incoming connections. ^C to exit.\") eventLoop.Handle(func(s *socket.Socket) { reader := bufio.NewReader(s) for { line, err := reader.ReadString('\\n') if err != nil || strings.TrimSpace(line) == \"\" { break } s.Write([]byte(line)) } s.Close() }) } 处理函数会根据换行符逐行读取数据内容，直到它读取到空行，然后会关闭连接。 我们可以通过 curl 来测试，curl 将会发送一个 GET 请求，并输出响应的内容，响应内容其实就是它发送的 GET 请求体的内容。\n思考 我们成功用 kqueue 实现了一个简单的 TCP Server，当然，这个代码想用于生产环境还需要做很多工作。 我们使用单进程和阻塞 socket 运行，另外，也没有去处理错误。 其实大多数情况下，使用已经存在的库而不是自己调用操作系统内核函数会更好。\n没想到用内核操作事件这么难，API 非常复杂，而且必须要读好多文档去找需要怎么做。 然而，这是一个惊人的学习体验。\nvia: https://dev.to/frosnerd/writing-a-simple-tcp-server-using-kqueue-cah\n作者：Frank Rosner 译者：h1z3y3 校对：polarisxu\n本文由 GCTT 原创编译，Go 中文网 荣誉推出\n","description":"","tags":["Golang","GCTT"],"title":"用 kqueue 实现一个简单的 TCP Server","uri":"/posts/writing-a-tcp-server-using-kqueue/"},{"categories":null,"content":"英文原文链接：https://www.zdnet.com/article/http-over-quic-to-be-renamed-http3/\n据 IETF 官方人员透露，HTTP-over-QUIC 实验方案将会被命名为 HTTP/3，并将成为 HTTP 协议的第三个官方版本。 在谷歌将 SPDY 技术发展成为 HTTP/2 协议之后，这是谷歌第二次将实验技术发展成为 HTTP 的官方协议版本。 HTTP-over-QUIC 协议是 HTTP 协议的升级，谷歌使用 QUIC 取代 TCP (Transmission Control Protocal) 作为 HTTP 的基础技术。 QUIC 全称 Quick UDP Internet Connections，是谷歌将 TCP 协议重写为一种结合了HTTP/2、TCP、UDP 和 TLS 的改进技术。\n谷歌希望 QUIC 能逐渐取代 TCP 和 UDP 成为在因特网传输二进制数据协议的新选择，而使用它的更好的理由，是 QUIC 的加密方案实现已经被测试证明更快而且更安全 (目前 HTTP-over-QUIC 协议草案使用的是 TLS1.3 协议)。\nQUIC 被提议作为2015年 IETF 的标准草案，而 HTTP-over-QUIC 这个基于 QUIC 而不是 TCP 重写 HTTP 的协议则在2016年7月被提议。 在那之后，HTTP-over-QUIC 在 Chrome 29、Opera 16 被支持，当然还有一些低性能的浏览器。最初，只有谷歌的服务器支持 HTTP-over-QUIC，今年，Facebook也开始采用这项技术。 在2018年10月份的邮件讨论里，IETF HTTP 和 QUIC 工作组的主席 Mark Nottingham 提出了将 HTTP-over-QUIC 重命名为 HTTP/3 的官方申请，并希望将 QUIC 工作组的开发工作转递给 HTTP 工作组。 经过几天的讨论，Nottingham 的提议被 IETF 的成员接受并给出了官方认可，将 HTTP-over-QUIC 作为 HTTP 协议的下一个版本 —— HTTP/3，用于完善优化当今的网络。 根据 W3Techs 的统计，截止2018年11月，全球访问量最高的1千万个网站中，已经有31.2%的网站支持了 HTTP/2，只有1.2%的网站支持了 QUIC。\n以下是自己的一点思考：\n可以看到，HTTP/3 协议带来的最大改变是协议底层将采用 UDP 协议，而不再是 TCP 协议，那这样的好处可以说是更低时延和更好的拥塞控制，还有更高效率的多路复用，可以说谷歌真的很厉害了，要知道 HTTP/2 也是谷歌的 SPDY 标准化之后的协议。而且这次 QUIC 发音同 quick ，上次 SPDY 发音同 speedy，是巧合还是有意为之呢。：）\n真是强者制定规则：\nThey are in control of future web protocol development.\n","description":"","tags":["HTTP"],"title":"译：HTTP/3 来了","uri":"/posts/http3/"},{"categories":null,"content":"工厂方法模式是简单工厂的升级。他创建一个用于实例化类的接口，并由工厂的子类决定实例化哪个类。工厂方法模式使得一个类的实例化延迟到子类。\n下面仍然以“两个数字的运算”作为例子\noperations.go // 运算类\npackage factory_method // 运算 type Operation interface { SetA(float64) SetB(float64) GetResult() (float64, error) } // 运算基类，实现公共的方法 type OperationBase struct { a float64 b float64 } func (oper *OperationBase) SetA(a float64) { oper.a = a } func (oper *OperationBase) SetB(b float64) { oper.b = b } // 加法运算 type AddOperation struct { *OperationBase } func (oper *AddOperation) GetResult() (float64, error) { return oper.a + oper.b, nil } // 减法运算 type SubOperation struct { *OperationBase } func (oper *SubOperation) GetResult() (float64, error) { return oper.a - oper.b, nil } // 乘法元算 type MulOperation struct { *OperationBase } func (oper *MulOperation) GetResult() (float64, error) { return oper.a * oper.b, nil } factory_method.go // 工厂类\npackage factory_method // 工厂类 type OperationFactory interface { CreateOperation() Operation } // 加法工厂 type AddFactory struct { } func (f *AddFactory) CreateOperation() Operation { return \u0026AddOperation{ OperationBase: \u0026OperationBase{}, } } // 减法工厂 type SubFactory struct { } func (f *SubFactory) CreateOperation() Operation { return \u0026SubOperation{ OperationBase: \u0026OperationBase{}, } } // 乘法工厂 type MulFactory struct { } func (f *MulFactory) CreateOperation() Operation { return \u0026MulOperation{ OperationBase: \u0026OperationBase{}, } } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/04_factory_method\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：工厂方法模式","uri":"/posts/design-pattern-factory-method/"},{"categories":null,"content":"代理模式即在真实类的基础上封装一层代理类，由代理类完成对真实类的调用。 以便可以在代理类中做一些额外的工作，如进行访问权限校验、保存Cache缓存等操作。\n下面以\"读取图片资源\"为例说明代理模式：\npackage proxy // 接口，代理类和真实类都要实现 type Image interface { Get() string } // 真实的图片类 type RealImage struct {} func (r *RealImage) Get() string { return \"real_image_url\" } // 代理类 type ImageProxy struct { realImage RealImage } // 由代理类进行原类的调用，从而能在原类基础上做一些操作 func (r *ImageProxy) Get() string { var res string // pre: 权限检查、查看是否有cache等 res += \"pre:\" res += r.realImage.Get() // after: 保存cache、格式化结果等 res += \":after\" return res } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/03_proxy\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：代理模式","uri":"/posts/design-pattern-proxy/"},{"categories":null,"content":" 平均负载是单位时间内“正在使用CPU”、“等待CPU”、“等待IO”的进程数量 平均负载和CPU使用率不一样，但是CPU密集型任务可能导致平均负载升高 由1，2可知，平均负载升高，不一定是由于CPU使用率高导致，也可能是IO繁忙 除了top命令，还有mpstat、pidstat等命令 watch命令，可以检测一个命令的执行结果，而不必一次次手动输入运行 uptime命令 ","description":"","tags":["Linux"],"title":"Linux:平均负载","uri":"/posts/linux-avarage-load/"},{"categories":null,"content":"装饰器模式主要解决要动态的给一个类添加一些新功能，而又不想让这个类变得庞大。 这种模式需要创建一个装饰类来包装扩展原有的类，并且在保证原有的类保持结构一致的前提下，提供额外的功能。\n下面是给一个人装饰衣服的实例：\npackage decorator import \"fmt\" type Person interface { Show() } // 具体实现 type ConcreteComponent struct { } func (c *ConcreteComponent) Show() { fmt.Print(\"A Person wears sunglasses; \") } // 男人 type Man struct{} func (m *Man) Show() { fmt.Print(\"A man wear a hat!\") } // 女人 type Woman struct{} func (w *Woman) Show() { fmt.Print(\"A woman wear a skirt!\") } // TShirt type TShirtDecorator struct { Person Color string } func (t *TShirtDecorator) Show() { t.Person.Show() // 调用父类的 Show() 方法 // \"装饰\": 增加自己特有的属性 fmt.Print(fmt.Sprintf(\"Color: %s, TShirt; \", t.Color)) } func WearTShirt(p Person, c string) Person { return \u0026TShirtDecorator{ Person: p, Color: c, } } // Pants type PantsDecorator struct { Person Length int64 } func (p *PantsDecorator) Show() { p.Person.Show() fmt.Print(fmt.Sprintf(\"Lenght: %dcm, Pants.; \", p.Length)) } func WearPants(p Person, l int64) Person { return \u0026PantsDecorator{ Person: p, Length: l, } } // Shoes type ShoesDecorator struct { Person Size int64 } func (s *ShoesDecorator) Show() { s.Person.Show() fmt.Print(fmt.Sprintf(\"Size: %d, Shoes; \", s.Size)) } func WearShoes(p Person, s int64) Person { return \u0026ShoesDecorator{ Person: p, Size: s, } } // Examples func ExampleConcrete_Wear() { var p Person = \u0026ConcreteComponent{} p = WearTShirt(p, \"Blue\") p = WearPants(p, 100) p = WearShoes(p, 42) p.Show() // Output: A Person wears sunglasses; Color: Blue, TShirt; Lenght: 100cm, Pants.; Size: 42, Shoes; } func ExampleMan_Show() { var xiaoming Person = \u0026Man{} xiaoming = WearShoes(xiaoming, 43) xiaoming = WearTShirt(xiaoming, \"White\") xiaoming.Show() // Output:A man wear a hat!Size: 43, Shoes; Color: White, TShirt; } func ExampleWoman_Show() { var xiaohong Person = \u0026Woman{} xiaohong = WearTShirt(xiaohong, \"Red\") xiaohong = WearShoes(xiaohong, 38) xiaohong.Show() // Output: A woman wear a skirt!Color: Red, TShirt; Size: 38, Shoes; } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/02_decorator\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：装饰器模式","uri":"/posts/design-pattern-decorator/"},{"categories":null,"content":"在策略模式中，我们需要创建一系列策略对象和一个能随策略对象改变而改变的Context对象，策略对象改变Context的执行方法。\n仍以两个数字的加减乘除操作作为示例\npackage strategy import \"fmt\" // Context 类 type Context struct { strategy Strategy } func NewContext(strategy Strategy) *Context { return \u0026Context{ strategy: strategy, } } func (c *Context) GetResult(a float64, b float64) (float64, error) { return c.strategy.GetResult(a, b) } // 策略接口 type Strategy interface { GetResult(a float64, b float64) (float64, error) } // 以下类实现策略接口 // 加法 type Add struct{} func (o *Add) GetResult(a float64, b float64) (float64, error) { return a + b, nil } // 减法 type Sub struct{} func (o *Sub) GetResult(a float64, b float64) (float64, error) { return a - b, nil } // 乘法 type Mul struct{} func (o *Mul) GetResult(a float64, b float64) (float64, error) { return a * b, nil } // 除法 type Div struct{} func (o *Div) GetResult(a float64, b float64) (float64, error) { if b == 0 { return 0, fmt.Errorf(\"除数不能为0\") } return a / b, nil } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/01_strategy\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：策略模式","uri":"/posts/design-pattern-strategy/"},{"categories":null,"content":"这个系列是《大话设计模式》的读后感，将书中的设计模式用golang实现。\n第一个设计模式是简单工厂模式，主要用到的知识点是类的多态。 多态表示不同的类可以执行相同的方法，但要通过它们自己的实现代码来执行。 而在golang中没有类的概念，我们可以借助接口(interface)类型实现类的多态。\n如果一个类型实现了接口的所有方法，那么就可以说这个类型实现了这个接口。\n我们要实现两个数字的加减乘除操作作为示例\npackage simplefactory import \"fmt\" // 1. 定义一个接口类型，子类必须实现GoResult方法来实现该接口 type Operation interface { GetResult(a float64, b float64) (float64, error) } // 2. 初始化工厂类方法，传入操作符，返回对应的类 func NewOperation(oper string) Operation { switch oper { case \"+\": return \u0026operationAdd{} case \"-\": return \u0026operationSub{} case \"*\": return \u0026operationMul{} case \"/\": return \u0026operationDiv{} default: return nil } } // 加法 type operationAdd struct{} func (o *operationAdd) GetResult(a float64, b float64) (float64, error) { return a + b, nil } // 减法 type operationSub struct{} func (o *operationSub) GetResult(a float64, b float64) (float64, error) { return a - b, nil } // 乘法 type operationMul struct{} func (o *operationMul) GetResult(a float64, b float64) (float64, error) { return a * b, nil } // 除法 type operationDiv struct{} func (o *operationDiv) GetResult(a float64, b float64) (float64, error) { if b == 0 { return 0, fmt.Errorf(\"除数不能为0\") } return a / b, nil } 源码以及测试源码下载地址：https://github.com/h1z3y3/big-talk-go-design-patterns/tree/master/00_simple_factory\n","description":"","tags":["设计模式","Golang"],"title":"设计模式：简单工厂模式","uri":"/posts/design-pattern-simple-factory/"},{"categories":null,"content":" 计算密集型任务\n计算密集型任务主要消耗CPU资源，需要进行大量的计算，如计算圆周率或对视频进行高清的解码等，全靠CPU的运算能力。 这种任务虽然可以利用多任务去完成，但是任务越多，花在任务切换上的时间就会越多，那么CPU的执行效率就会越低， 所以，要高效的利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数，尽量减少CPU在任务间的切换时间。\nIO密集型任务\n一般涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点就是CPU消耗很少，任务的大部分时间都花在等待IO操作的完成。 由于IO的速度远远低于CPU和内存的速度，所以IO密集型任务的数量越多，CPU的效率就会越高，但是也会有一定的限度。 常见的大部分任务都是IO密集型任务，比如Web应用。\nIO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换Python这样运行速度极低的脚本语言， 也完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高，代码量最少的语言，脚本语言是首选，C语言最差。\n总结\n计算密集型程序适合C语言多线程 IO密集型程序适合脚本语言开发的多线程\n","description":"","tags":["基础"],"title":"计算密集型 vs. IO密集型","uri":"/posts/cpu-io/"},{"categories":null,"content":"最近在做毕业设计，使用到了CkEditor和CkFinder来做富文本编辑框以及文件管理。 因为CkFinder只能下载使用Demo版本，会有一些版权信息。 我不是用做商业目的，仅仅为了学习，所以想把版权信息去掉。 看了几篇博客，都是教你把alert框加上display:none，我考虑到这样并不好，因为如果有其他正常的信息也不能显示了，所以花了些时间改了下ckfinder.js，既去掉了版权信息，又不会影响其他信息的提示。\n下文提供了两种方法，建议使用第二种。\n如果你是用于商业目的，请到官网购买使用的License使用。\nCKFinder版本: Version: 2.6.2.1 • Released 11 Oct 2016\n不想自己操作这么麻烦的，去CSDN下载我上传好的，2积分 哈哈哈\n链接：http://download.csdn.net/detail/qq1255685485/9845062\n第一种 第一种麻烦而且需要逻辑改动较大。\n左下角信息 在ckfinder.js中搜索:\nt=\"\\x54\\150\\151\\163\\040\\x69\\163\\x20\\164\\x68\\145\\040\\x44\\105\\x4d\\x4f\\040\\166\\x65\\x72\\x73\\x69\\157\\156\\x20\\157\\146\\040\\103\\113\\x46\\151\\x6e\\144\\145\\x72\\056\\040\\120\\154\\x65\\141\\163\\145\\040\\166\\x69\\x73\\x69\\x74\\x20\\164\\150\\145\\040\\x3c\\x61\\x20\\150\\162\\x65\\x66\\x3d\\x27\\150\\164\\x74\\x70\\x3a\\x2f\\x2f\\x63\\x6b\\163\\157\\x75\\x72\\x63\\x65\\056\\143\\x6f\\x6d\\057\\143\\153\\146\\151\\x6e\\144\\x65\\162\\x27\\x20\\164\\141\\162\\x67\\x65\\x74\\x3d\\047\\x5f\\x62\\154\\141\\x6e\\x6b\\x27\\x3e\\x43\\x4b\\106\\151\\156\\144\\x65\\x72\\040\\x77\\145\\x62\\040\\163\\151\\x74\\x65\\x3c\\x2f\\x61\\x3e\\x20\\164\\157\\040\\x6f\\x62\\x74\\141\\x69\\x6e\\x20\\141\\040\\166\\x61\\154\\151\\144\\040\\x6c\\151\\x63\\x65\\156\\163\\x65\\x2e\" 位置在文件比较靠后的位置，替换为:\nt=\"\" 这一句的解码后为:\nThis is the DEMO version of CKFinder.Please visit the \u003ca href='http://cksource.com/ckfinder' target='_blank'\u003eCKFinder web site\u003c/a\u003e to obtain a valid license. 可以在 http://ddecode.com/hexdecoder 解码\n顶端信息 在ckfinder.js中搜索:\nP=\"\\x50\\x6c\\x65\\141\\x73\\x65\\040\\166\\151\\x73\\x69\\x74\\x20\\164\\x68\\x65\\040\\074\\141\\040\\x68\\162\\x65\\146\\075\\x27\\x68\\164\\x74\\160\\072\\057\\057\\x63\\x6b\\x73\\x6f\\x75\\x72\\x63\\x65\\056\\x63\\157\\155\\057\\143\\x6b\\x66\\151\\x6e\\x64\\x65\\x72\\x27\\x20\\x74\\141\\162\\147\\145\\x74\\x3d\\x27\\x5f\\x62\\154\\141\\x6e\\153\\x27\\x3e\\x43\\x4b\\106\\x69\\x6e\\x64\\x65\\162\\x20\\x77\\x65\\142\\x20\\x73\\x69\\x74\\145\\x3c\\x2f\\x61\\x3e\\040\\x74\\x6f\\x20\\157\\142\\x74\\x61\\151\\156\\x20\\141\\040\\166\\141\\154\\151\\x64\\040\\154\\151\\143\\145\\x6e\\163\\145\\x2e\",Q=\"\\x54\\150\\x69\\163\\x20\\151\\x73\\040\\x74\\x68\\x65\\040\\x44\\x45\\x4d\\117\\040\\x76\\x65\\x72\\163\\x69\\157\\156\\x20\\157\\x66\\040\\x43\\x4b\\106\\x69\\156\\144\\145\\x72\\x2e\\x20\"+P,R=\"\\x50\\162\\157\\144\\x75\\x63\\164\\040\\154\\151\\143\\x65\\156\\163\\145\\x20\\150\\141\\x73\\x20\\x65\\x78\\160\\x69\\162\\145\\144\\x2e\\040\"+P; 这里定义了三个变量P, Q, R, 分别代表的意思如下:\nP=\"Please visit the \u003ca href='http://cksource.com/ckfinder' target='_blank'\u003eCKFinder web site\u003c/a\u003e to obtain a valid license.\"; Q=\"This is the DEMO version of CKFinder.\" + P; R=\"Product license has expired.\" + P; 将搜索到的内容替换为\nP=\"\"; Q=\"\"; R=\"\"; 替换完成后发现文件库为空白，更具体可以说，当将Q设置为空白字符串之后才会显示空白，而替换P和R都不会出现这种情况，因为代码后面对Q的值做了判断.\n所以我们继续向下看，继续搜索：\nif(!Q) 可以看到这个判断if(!Q) return;,删除这一个判断体.\n还没有结束，继续搜索:\nQ.charAt 可以看到另外一个判断if(pw||Q.charAt(2\u003c\u003c2)!='t')return;，为了保证正常使用，将这个判断体替换为:\nif(pw) return; 另外多说一句，Q变量删除到Q=\"\\x54\\150\\x69\\163\\x20\\151\\x73\\040\\x74\"的时候还能正常使用，也就是Q=\"This is t\"，可以做些尝试。\n当以上工作全部完成之后，刷新页面即可以看到版权信息全部去掉了，而且并没有影响到其他信息的提醒。\n哈哈哈😂。看到这的都是真爱。 那么给你们说一个更简单的方法，只需三步，更完美的解决问题。\n第二种 简单，只需三步\n左下角信息 搜索: this.dV().getChild(0).appendHtml，很显然是为左下角添加信息，看这一句上面有个if判断:\nif (this.app.gd == 'bootstrap') { var H = \"\\x3c\\x64\\151\\x76\\x20\\143\\x6c\\x61\\x73\\x73\\x3d\\x27\\166\\x69\\145\\167\\x20\\164\\157\\157\\154\\137\\160\\141\\x6e\\145\\x6c\\047\\040\\x73\\x74\\x79\\154\\145\\075\\047\\x64\\151\\x73\\x70\\154\\141\\x79\\x3a\\x62\\x6c\\157\\143\\153\\x20\\x21\\x69\\x6d\\160\\157\\x72\\164\\x61\\x6e\\164\\x3b\\160\\x6f\\163\\x69\\x74\\151\\x6f\\x6e\\072\\x73\\x74\\x61\\164\\151\\143\\040\\x21\\x69\\x6d\\160\\157\\x72\\164\\x61\\x6e\\x74\\x3b\\x63\\x6f\\x6c\\157\\x72\\x3a\\043\\x33\\x31\\x37\\x30\\x38\\x66\\x20\\041\\151\\155\\x70\\157\\x72\\x74\\x61\\156\\x74\\073\\x62\\x61\\x63\\x6b\\147\\162\\157\\165\\x6e\\144\\055\\143\\157\\x6c\\x6f\\x72\\x3a\\x23\\144\\x39\\145\\144\\146\\x37\\x20\\x21\\x69\\x6d\\x70\\157\\x72\\x74\\141\\156\\x74\\073\\146\\x6f\\156\\164\\x2d\\x73\\151\\172\\x65\\x3a\\x20\\061\\063\\x70\\170\\073\\040\\x70\\141\\x64\\144\\x69\\156\\147\\072\\040\\x35\\x70\\170\\073\\x20\\155\\141\\162\\147\\x69\\x6e\\072\\065\\160\\170\\x3b\\x62\\157\\162\\144\\x65\\162\\055\\x72\\141\\144\\x69\\x75\\x73\\x3a\\x34\\160\\x78\\x3b\\047\\x3e\"; v = H + t + s; w = H + u + s; } 进行解码和字符串组合，可以看到变量v就是版权信息, w是已经购买的信息。在搜索到的this.dV().getChild(0).appendHtml括号里面，改为:\nthis.dV().getChild(0).appendHtml(C||D||A!=4?\"\":\"\"); 简言之就是不管买没买，都不显示这个提示，设置为空字符串就好了。\n顶端信息 顶端的去处版权信息的方法和左下角类似。\n搜索: aT.mj=Q 替换为 aT.mj=Q.toLowerCase().indexOf(\"demo\") ? \"\" : Q; 搜索: aT.mj=R 替换为 aT.mj=R.toLowerCase().indexOf(\"demo\") ? \"\" : R;\n大功告成， 更完美的解决了问题～ 😎\n2017-5-17 更新：启用剪切功能 今天发现虽然版权信息没有了，但是“临时文件夹”功能“从临时文件夹剪切至此”在Demo版本中不能使用，提示:\nThis function is disabled in the demo version of CKFinder. Please visit the CKFinder web site to obtain a valid license. 启用方法：\n搜索z.app.msgDialog, 可以看到包含它的是一个判断。\nif('balabalabalabalabala...') //这个判断很长 显示这是Demo版本，不能用这个功能; else 执行指令; 那我们要做的就是只留下需要执行的指令就可以了。 这一步完成，就可以从临时文件中移动文件了。\n和第1步类似，搜索y.msgDialog,同样包含它的是一个判断，不同的是这个判断体的else部分执行了多条指令。删除判断只留下指令就可以了。\n这一步完成，就可以在各个文件夹中移动文件了。\n这样文件的移动功能就可以正常使用了。我好像太坏了。\n","description":"","tags":["J2EE","CKFinder","CKEditor"],"title":"去除CKFinder版权信息以及启用文件移动功能","uri":"/posts/remove-ckfinder-copyright/"},{"categories":null,"content":"Apache Shiro用于权限管理十分方便，但存在一个问题，就是当用户的权限发生变化的时候，就需要用户重新登录，重新缓存用户的权限信息。\n现在想要在改变用户的权限的时候，清理用户的权限。 在写的过程中查找了一些资料，但是并没有成功实现权限的清理，所以我进行了一些修改，并实现了Helper类。\n我写的帮助类：\npackage com.zhaoyang.core.feature.security; import org.apache.shiro.SecurityUtils; import org.apache.shiro.cache.Cache; import org.apache.shiro.cache.CacheManager; import org.apache.shiro.subject.SimplePrincipalCollection; import org.apache.shiro.subject.Subject; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * @author zhaoyang * * @since 2017-04-04 2:12 PM */ public class ShiroAuthorizationHelper { //shiro 配置的cacheManager， 需要使用Spring bean进行注入 private static CacheManager cacheManager; private static Logger logger = LoggerFactory.getLogger(ShiroAuthorizationHelper.class); /** * 清除用户的权限 * * 这里需要注意的是， * 网上很多实现都是这里只传递一个String类型的username过来，根据这个String当key去清除Cache * 但是Shiro在缓存用户权限的时候使用的key并不是String类型，所以调用remove的时候并不能清除缓存的权限 * * shiro缓存时使用的key，是登录时使用的SimplePrincipalCollection对象，所以remove的时候需要的不是一个String值， * 具体可以参考下面方法中打印cache的key的过程, 可以看到打印出key的类是 `class org.apache.shiro.subject.SimplePrincipalCollection` * 所以你cache.remove(String username)肯定清除不了 * * @param principal */ public static void clearAuthorizationInfo(SimplePrincipalCollection principal) { logger.info(\"clear the user: \" + principal.toString() + \"'s authorizationInfo\"); Cache\u003cObject, Object\u003e cache = cacheManager.getCache(\"myShiroCache\");//myShiroCache是我配置用于缓存的cache的Name，在spring配置文件中配置，可以看文章最后 // for (Object k : cache.keys()) { // System.out.println(k.getClass()); // } cache.remove(principal); } /** * 清除当前用户的权限 */ public static void clearAuthorizationInfo() { if (SecurityUtils.getSubject().isAuthenticated()) { Subject subject = SecurityUtils.getSubject(); String username = subject.getPrincipal().toString(); String realmName = subject.getPrincipals().getRealmNames().iterator().next(); SimplePrincipalCollection principalCollection = new SimplePrincipalCollection(username, realmName); // 调用清理用户权限 clearAuthorizationInfo(principalCollection); } } /** * 由Spring bean将对象注入 * @param cacheManager */ public static void setCacheManager(CacheManager cacheManager) { ShiroAuthorizationHelper.cacheManager = cacheManager; } } 将cacheManager注入到帮助类：\n\u003c!-- 注入Shiro帮助类的cacheManager --\u003e \u003cbean class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\"\u003e \u003cproperty name=\"staticMethod\" value=\"com.damaiya.DMYSite.core.feature.security.ShiroAuthorizationHelper.setCacheManager\"/\u003e \u003cproperty name=\"arguments\" ref=\"shiroEhcacheManager\"/\u003e \u003c/bean\u003e 当然ref=“shiroEhcacheManager”需要你自己去实现, 我这里贴下我的：\n\u003c!-- 缓存管理器 使用Ehcache实现 --\u003e \u003cbean id=\"shiroEhcacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\"\u003e \u003cproperty name=\"cacheManagerConfigFile\" value=\"classpath:ehcache-shiro.xml\"/\u003e \u003c/bean\u003e 下面是ehcache-shiro.xml配置, 具体的参数作用我就不说了:\n\u003cehcache updateCheck=\"false\" name=\"shiroCache\"\u003e \u003cdefaultCache maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" overflowToDisk=\"false\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\" /\u003e \u003ccache name=\"myShiroCache\" maxElementsInMemory=\"10000\" eternal=\"false\" timeToIdleSeconds=\"30\" timeToLiveSeconds=\"0\" overflowToDisk=\"false\" diskPersistent=\"false\" diskExpiryThreadIntervalSeconds=\"120\"/\u003e \u003c/ehcache\u003e 使用指定Name的Cache进行权限缓存配置, securityRealm是我自己的Realm：\n\u003cbean id=\"securityRealm\" class=\"com.damaiya.DMYSite.web.security.SecurityRealm\"\u003e \u003cproperty name=\"authorizationCacheName\" value=\"myShiroCache\"/\u003e \u003c/bean\u003e 这样整个配置就完成了，而且调用clearAuthorizationInfo()时就可以清除当前登录用户的权限信息了。\n","description":"","tags":["J2EE","Shiro"],"title":"Shiro清除更新缓存的用户权限","uri":"/posts/shiro-clear-update-authorization/"},{"categories":null,"content":"在J2EE项目中使用Shiro进行权限验证后，每次部署跳转到登录界面总会在链接后面多出;JSESSION=xxxx，查了很多，大概有下面几种方法：\n在web.xml中添加以下代码：\n\u003csession-config\u003e \u003ctracking-mode\u003eCOOKIE\u003c/tracking-mode\u003e \u003c/session-config\u003e 具体请参考：\nhttp://stackoverflow.com/questions/11327631/remove-jsessionid-from-url\n使用Filter对URL进行rewrite\n具体请参考：\nhttp://dr-yanglong.github.io/2015/07/07/del-jeesessionid/\n有些同学重写了shiro重定向时需要调用的方法encodeRedirectURL()和toEncoded()\n具体请参考：\nhttp://dwangel.iteye.com/blog/2275899\nhttp://alex233.blog.51cto.com/8904951/1856155\n后来去看了源码，发现了一个最最简单的方法，如下：\nshiro源码：\nhttps://github.com/apache/shiro/pull/31/commits/7f37394c6048d8c8a214eabd312721ddb51adc9b\n阅读源码之后，可以发现DefaultWebSessionManager.java文件中添加了新属性private boolean sessionIdUrlRewritingEnabled;, 顾名思义, 是用来控制是否重写URL添加SESSIONID的，只要修改shiro的sessionManager配置如下即可：\n\u003cbean id=\"sessionManager\" class=\"org.apache.shiro.web.session.mgt.DefaultWebSessionManager\"\u003e ... \u003cproperty name=\"sessionIdUrlRewritingEnabled\" value=\"true\"/\u003e ... \u003c/bean\u003e More Source： https://fralef.me/tomcat-disable-jsessionid-in-url.html\n","description":"","tags":["J2EE","Shiro"],"title":"最简单方法解决使用Shiro后URL中JSESSIONID的问题","uri":"/posts/tomcat-shiro-disable-jsessionid-in-url/"},{"categories":null,"content":"grep 概述 在给出文件列表或标准输入后, grep会对匹配一个或多个正则表达式的文本进行搜索, 并输出匹配（或者不匹配）的行或文本.\n使用格式 grep [options] PATTERN [FILE...] 常用选项 -i 忽略字符大小写 -v 显示未被模式匹配到的行或串 -o 只显示匹配到的串而不是整行 -n 显示匹配的行及行号 -E 使用扩展的正则表达式 -A n 显示出匹配到的行和后n行 -B n 显示出匹配到的行和前n行 -C n 显示出匹配到的行和前后各n行 扩展的正则表达式\n扩展正则表达式与基础正则表达式的唯一区别在于: () {} ? + 这几个字符.\n基础正则表达式中, () {} ? + 表示特殊含义，使用时需要将他们转义\n而扩展正则表达式中, () {} ? + 不表示特殊含义, 你需要将他们转义.\n转义符号, 都是一样的: 反斜线 \\ .\n所谓特殊含义, 就是正则表达式中的含义. 非特殊含义, 就是这个符号本身.\n正则表达式 元字符 . 匹配任意单个字符 [] 匹配[]指定范围内的任意单个字符 [^] 匹配[]指定范围外的任意单个字符 字符集 [:digit:] 数字 [:lower:] 小写字母 [:upper:] 大写字母 [:punct:] 标点符号 [:space:] 空白字符 [:alpha:] 所有字母 [:alnum:] 所有字母和数字, 非标点 例1.1\n$ grep '[[:punct:]]' grep_example # 所有有标点的行 匹配次数 .* 匹配任意字符串 * 前面的字符重复任意次数, 0次1次或多次 + 前面的字符重复1次或多次 ? 前面的字符重复0次或者多次 {m, n} 匹配前面的字符至少m次, 至多n次 {m, } 匹配前面的字符至少m次 位置锚定 ||| | ^ | ^后面的字符必须出现在行首 | | $ | $前面的字符必须出现在行尾 | | ^$ | 空白行 | | \u003c | \u003c后面的字符必须出现在词首 | | \u003e | \u003e前面的字符必须出现在词尾 | | () | ()中的当做一个整体匹配 |\n例1.2\n$ grep -E '.*(d+)' grep_example $ grep -E '.*(d+)$' grep_example sed 概述 sed (意为流编辑器, 源自英语\"Stream Editor\"的缩写)\nsed用来把文档或字符串里面的文字经过一系列编辑命令转换为另一种格式输出.\nsed通常用来匹配一个或多个正则表达式的文本进行处理.\n模式空间\n模式空间: 把当前处理的行存储在临时的缓冲区, 称为\"模式空间\"(Pattern Space)\n模式空间就是读入行所在的缓存，sed对文本行进行的处理都是在这个缓存中进行的。\n使用格式 sed 'Address Command' [FILE...] 常用选项 -n 不显示模式空间中的内容 -i 直接修改原文件 -r 使用扩展的正则表达式 Address 1. StartLine, EndLine: # 开始行, 结束行 # 如: 1, 100 表示 1 到 100 行 2. /RegExp/ # 正则表达式 3. /pattern1/, /pattern2/ # 从匹配到/pattern1/开始, 一直到匹配到/pattern2/结束中间所有的行 4. LineNumber # 指定的某一行 5. StartLine, +N # 从StartLine开始后面N行 Command d 删除满足模式的行 p 显示满足模式的行 a \\string 在满足模式的行后添加新行, 内容为string串的内容 i \\string 在满足模式的行前添加新行, 内容为string串的内容 r file：将指定的文件的内容添加至符合条件的行后 w file：将地址指定范围内的行另存至指定的文件中 s \\pattern\\string\\修饰符 将满足pattern的串替换为string 修饰符: \\g 全局替换, 即将该行中所有匹配项替换, 默认只替换第一个匹配项 \\i 忽略大小写 \u0026 引用模式匹配的整个串 \\1 表示匹配到模式中的第一个 ( 开始的串 \\2 表示匹配到模式中的第二个 ( 开始的串 例2.1\n#从以hezhaoyang开头的行开始匹配, 一直到以I开头的行, 显示中间所有行 $ sed -n '/^hezhaoyang/,/^I/p' sed_example 例2.2\n#将sed_insert中的内容插入到以hezhaoyang开头的行后 $ sed '/hezhaoyang/r sed_insert' sed_example awk 概述 AWK是一种处理文本文件的语言. 它将文件作为记录序列处理. 在一般情况下，文件内容的每行都是一个记录. 每行内容都会被分割成一系列的域, 因此, 我们可以认为一行的第一个词为第一个域,第二个词为第二个, 以此类推. AWK程序是由一些处理特定模式的语句块构成的. AWK一次可以读取一个输入行. 对每个输入行, AWK解释器会判断它是否符合程序中出现的各个模式, 并执行符合的模式所对应的动作。\n——阿尔佛雷德·艾侯，The A-Z of Programming Languages: AWK\n使用格式 awk [options] 'BEGIN{ } pattern{ } END{ }' 常用选项 -F fs : 指定分隔符为fs -v var=value : 定义可传递给awk的变量 -f scriptfile : 从脚本文件中读取awk命令 基本结构 一个awk脚本通常由: BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成, 这三个部分是可选的. 任意一个部分都可以不出现在脚本中, 脚本通常是被单引号或双引号中.\nawk 的工作过程 第一步: 执行BEGIN{ commands }语句块中的语句; 第二步: 从文件或标准输入(stdin)读取一行, 然后执行pattern{ commands }语句块, 它逐行扫描文件, 从第一行到最后一行重复这个过程, 直到文件全部被读取完毕. 第三步: 当读至输入流末尾时, 执行END{ commands }语句块.\nBEGIN语句块在awk开始从输入流中读取行之前被执行, 这是一个可选的语句块, 比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中. END语句块在awk从输入流中读取完所有的行之后即被执行, 比如打印所有行的分析结果这类信息汇总都是在END语句块中完成, 它也是一个可选语句块. pattern语句块中的通用命令是最重要的部分, 它也是可选的. {} 相当于一个循环体, 它会对文件中的每一行进行迭代.\n输出 print / printf print 当要输出多个变量时, 应该用逗号’,‘分隔\n$ echo | awk '{ var1=\"v1\"; var2=\"v2\"; var3=\"v3\"; print var1,var2,var3; }' 只写 print 相当于 print $0, 如果想要输出空行, 应该写做: print ''\n$1, $2, $3 … 分别对应该行的第1个, 第2个, 第3个字段, 以此类对\nprintf 与 print 的区别在于 printf 需要格式化输出.\n%c 字符类型 %d, %i 十进制 %e, %E 科学计数法输出数值 %f 浮点数类型 %g, %G 科学计数法或浮点数格式显示 %s 字符串 %u 无符号整数 %% %本身 修饰符 N: 宽度 -: 左对齐 +: 显示数值符号 注意: printf 默认不换行, 需要使用\"\\n\"\n例3.1:\n#输出用户名和使用的shell类型 $ head -10 /etc/passwd | awk -F: '{printf \"%-15s%s\\n\", $1, $7}' awk内置变量 记录变量 FS: field separator 字段分隔符, 默认为空白字符 RS: record separator 记录分隔符, 默认为换行符 OFS: output field separator 输出字段分隔符 ORS: output record separator 输出记录分隔符 数据变量 NR: number of input rows 处理的行数\nNF: number of fields 该行字段的个数\nARGV: 数组, 保存awk命令行. 如: $ awk ‘{ print $0 }’ a.txt b.txt中ARGV[0]=awk, ARGV[1]=a.txt\nARGC: awk命令参数的个数\nFILENAME: 所处理文件的名称\nIGNORECASE: IGNORECASE=1时忽略大小写\n$ echo \"TEST HHHH\" | awk '{IGNORECASE=1; if($1 == \"test\"){print \"ok\";}}' 赋值 $ awk -v var=\"value\" '{print var}' $ awk 'BEGIN{ var=\"value\"; print var; }' 操作符 + - * / ^ ** % 比较运算符 \u003c \u003c= \u003e= \u003e \u003e= == != x~y # True if the string x matches the regexp denoted by y # 如果字符串x被正则表达式y匹配, 则为真 x!~y 数组 定义 arr[1] = 'first' arr[2] = 'second' arr['year'] = 2016 arr['month'] = 8 长度 length() 获取字符串，数组的长度 split() 分割数组， 返回长度 asort() 排序数组， 返回长度 需要注意：\n判断数组是否包含某键值\n#错误写法 $ echo | awk 'BEGIN{a[\"a\"]=1;a[\"b\"]=2; if(a[\"c\"]!=1){print \"ok\"}; for(i in a) {print i, a[i];} }' #正确判断 $ echo | awk 'BEGIN{a[\"a\"]=1;a[\"b\"]=2; if(\"c\" in a){print \"ok\"}; for(i in a) {print i, a[i];} }' awk 中的数组是关联数组, 只要是通过他的数组引用过key, 就会自动创建该序列.\n多维数组 awk的多维数组本质上是一维数组, 更确切地说, awk是不支持以为多维数组的. 但是awk提供了逻辑上模拟多维数组的方式. 在awk中, array[1, 2]=1 , 这样的写法是允许的. 他是使用了一个特殊字符串SUBSEP(\\034)分隔键, [2, 4]实际上是[2SUBSEP4].\n访问可以使用for( (i, j) in array ){}但是必须用圆括号. 但是单独访问时, 必须使用split()将数组键值分开. 即:\narr[1,1] = 11; arr[1,2] = 12; arr[2,1] = 21; arr[2,2] = 22; for (a in arr) { split(a, tmp, SUBSEP); print tmp[1], tmp[2];z } 控制语句 1. if-else if (condition) {} else {} 2. while while (condition) {} 3. do-while do {} while (condition) 4. for for ( ; ; ) {} for (item in array) {} 5. switch switch (expression) { case x: ; case y: ;} 6. break, continue 7. next # 提前结束本行 内置函数 split(string, array [,fieldsep]) # 使用fieldsep分隔string, 并存储在名为array的数组中 #实例: $ awk '{ split( \"20:18:00\", time, \":\" ); print time[2] }' # 上例把时间按冒号分割到time数组内，并显示第二个数组元素18。 # 返回值为分割数组的长度 length(string) substr(string, start [, length]) system(command) : 执行命令并返回给awk systime() : 返回当前时间时间戳 tolower(string) toupper(string) match(string, regular expression) # match函数返回在字符串中正则表达式位置的索引, # 如果找不到指定的正则表达式则返回0, 找到返回1。 # match函数会设置内建变量RSTART为字符串中子字符串的开始位置, RLENGTH为到子字符串末尾的字符个数. # substr可利于这些变量来截取字符串. #实例： $ awk '{start=match(\"this is a test\",/[a-z]+$/); print start}' $ awk '{start=match(\"this is a test\",/[a-z]+$/); print start, RSTART, RLENGTH }' # 第一个实例打印以连续小写字符结尾的开始位置, 这里是11. # 第二个实例还打印RSTART和RLENGTH变量, 这里是11(start), 11(RSTART), 4(RLENGTH). 内建数学函数 1. cos(x) 余弦函数 2. exp(x) 求幂 3. int(x) 取整 4. log(x) 自然对数, 过程没有舍入 5. rand() 产生一个大于等于0而小于1的随机数 6. sin(x) 正弦 7. sqrt(x) 平方根 8. srand(x) x是rand()函数的种子 自定义函数 function F_NAME([variable]) { statements } # 函数还可以使用return语句返回值，格式为“return value” ","description":"","tags":["Linux"],"title":"Grep, Sed, Awk 日常使用","uri":"/posts/grepsedawk/"},{"categories":null,"content":"前言 没有接触过Vim的同学, 一定会觉得平时使用的IDE很好用, 但是当你开始使用Vim, 并且渐渐熟悉, 我觉得你会爱上这一款编辑器. 千万不要因为一开始Vim有太多命令需要记忆而放弃它.\n这篇博客是翻译自《Learn Vim Progressively》, 并在我觉得有必要添加说明的地方添加了自己的说明. 我认为是最适合入门Vim的教程, 没有之一.\n正文开始 你想以最快的方式自学Vim吗? 在人类最优秀的编辑器面前, 你必须至少先学会如何幸存下来, 然后再去一点点整合使用它的技巧.\nVim the Six Billion Dollar editor\nBetter, Stronger, Faster\n当你学会使用Vim, 它将成为你最后一个编辑器. 虽然学习它的过程很不容易, 但是最后它会难以置信的好用.\n下面4个步骤是你自学的感受:\n存活 使用顺手 更好, 更强, 更快 使用Vim的超能力 当你读完这篇文章, 你将会爱上vim.\n但是我们开始之前, 要先说明一点:\n学习vim的过程将是十分痛苦的 将花费一些时间, 千万不要觉得浪费时间儿放弃 学习他的过程就像是学习乐器, 一旦入门, 就会变得很轻松 不要奢望像其他编辑器一样三天之内就能熟练掌握, 学习vim至少需要两个星期而不是三天 Level 1 - 存活 安装vim 运行vim 不要做任何事情! 请先阅读 在普通编辑器中, 当你敲击键盘就能在屏幕上看到想要的字符. 但是对于Vim来讲, 不是这样的. 当你启动vim的时候, vim当前正在 Normal 模式下, 你需要先将模式切换为 Insert 模式, 才能够输入字符. 从 Normal 模式到 Insert 模式, 需要敲击键盘字符 i.\n当你进入*Insert模式, 你可能会感觉舒服一点, 因为你可以像普通编辑器一样输入字符了. 如果你想从Insert模式切换回Normal*模式, 只需要敲击键盘最左上角的键ESC键.\n现在你知道如何在*Insert模式和Normal模式之间切换了. 现在, 你必须要掌握下面几个命令以保证你能在Normal*模式下存活下去:\ni : 切换到*Insert模式. 按ESC返回Normal*模式 x : 删除当前光标所在的一个字符 :wq : 保存并退出 (:w 保存编辑的文件, :q 退出vim) dd : 删除光标所在的一行 p : 粘贴 #####推荐\nhjkl (强烈推荐但不强制使用): 你可以使用键盘的 ↑ ↓ ← → 进行光标的移动. 提示: 在*Normal*模式下, j代表方向 ↓ :help \u003ccommand\u003e : 显示 \u003ccommand\u003e 的帮助文档. 你可以直接输入 :help 而不输入 \u003ccommand\u003e 获取一般性帮助. 最开始, 你只需要上面5个命令. 当你很自然地使用以上命令, 抛弃之前普通编辑器的习惯, 那么你就可以到Level 2了.\n但是, 在*Normal模式下需要注意的是: 在普通编辑器下, Ctrl-C是复制命令, 这是个组合按键来完成一项复制的功能, 但是在vim下, 不可以轻易地使用Ctrl. 事实上, 在Vim的 Normal 模式下, vim已经赋予每一个按键功能, 也就是说, 在Normal*模式下, 每一个键都是功能键, 而不需要你按下Ctrl去组合其他按键实现某项功能.\n提示\n为了便于书写和阅读, 下面的文章中, \u003cC-λ\u003e 将代表键入 Ctrl-λ 命令都是以:开头, 并且最后要键入\u003center\u003e. 如: 当我写:q, 将代表:q\u003center\u003e Level 2 - 感觉顺手 你现在已经可以在vim中存活了. 现在是时候学点其他的命令了. 下面是我的建议(以下命令都是在*Normal*模式下键入):\n各种插入模式 a : 在当前光标后开始插入, 并且进入*Insert*模式 o : 从当前行下面插入新行, 并且进入*Insert*模式 O : 从当前行上面插入新行, 并且进入*Insert*模式 cw : 删除光标开始的单词, 并且进入*Insert*模式 基本的移动 0 : 到光标所在行的最开始 ^ : 到光标所在行第一个非空字符 $ : 到光标所在行的末尾 g_ : 到光标所在行最后一个非空字符 /pattern : 向下搜索字符串pattern ?pattern : 向上搜索字符串pattern 注: 搜索时, 键入n键可以查看下一项, 键入N键可以查看上一项\n复制/粘贴 p : 在当前光标后粘贴 P : 在当前光标前粘贴 yy: 复制光标所在整行 撤销/恢复 (Undo/Redo) u : 撤销 \u003cC-r\u003e : 恢复 载入/保存/退出/修改文件(Buffer) :e \u003cpath/to/file\u003e : 打开文件 :w : 保存文件修改 :saveas \u003cpath/to/file\u003e : 另存为\u003cpath/to/file\u003e :x, ZZ or :wq : 保存并退出. :wq相当于先:w再:q; :x只在需要时保存; ZZ不需要输入:和回车\u003center\u003e :q! : 强制退出而不保存修改. :qa!, 强制退出所有正在编辑的文件, 即使其他文件有做过修改而没有保存 :bn和:bp : 切换到下/上一个文件\n花一点时间去熟悉上面的命令. 当你熟练掌握之后, 你可以完成你在普通编辑器几乎所有功能. 你可能会觉得用vim还是有点别扭. 但是跟着我进入下一Level, 或许你可以明白为什么要花费这么多力气去学习它.\nLevel 3 - 更好. 更强. 更快. 恭喜你已经到达了Level 3! 我们现在开始学习一些有趣的东西. 在Level 3, 我们只讨论和vi编辑器兼容的那些命令.\n3.1 更好 让我们看看vim是怎么样帮助你做重复的命令的:\n.(点) : 重复上一次的命令 N\u003ccommand\u003e: 将会运行\u003ccommand\u003eN次, 这里的N是一个整数 下面是一个例子. 打开一个文件然后输入下面的命令:\n2dd : 将会删除2行 3p : 将会执行粘贴命令3次 100idesu [ESC] : 将会输入 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu” . : 跟在上一个命令后面代表再次输入100次\"desu\" 3. : 将会输入3次\"desu\"(而不是300次, 你看vim多么聪明) 3.2 更强 知道如何高效的在vim中移动光标十分重要. 不要跳过这一部分.\nNG : 移动光标到第N行 gg : 相当于 1G, 到文件的最开始一行 G : 到文件的最后一行 按照单词移动: w : 到下一个单词的开始 e : 到下一个单词的结尾 默认情况下, 我们认为单词是由一系列字符和下划线组成. 如果你认为由空格分隔开的字符串即为单词, 那么你只需要使用W和E. 现在介绍更高效的移动方式:\n% : 匹配括号移动光标, 如(),[],{} *和# : 匹配光标当前所在单词, 并且向下/上查找匹配的单词, 并把光标移到查找到的单词 相信我, 最后的三个命令是十分高效的.\n3.3 更快 记住如何移动光标了吗, 因为很多命令都是可以组合使用的. 并且大多是以以下格式:\n\u003cstart position\u003e\u003ccommand\u003e\u003cend position\u003e\n例如: 0y$ 意思是\n0 : 将光标移动到行首 y : 开始复制 $ : 复制到行尾 我们也可以使用ye, 从光标所在位置复制到单词结束. 也可以使用y2/foo, 从光标所在位置复制到匹配的第二个foo\n对y(复制)来说是这样的, 那么对d(删除), v(可视化选择), gU(转大写), gu(转小写)等等命令来说也是同样适用的\nLevel 4 - 适用Vim的超能力 «未完待续»\n","description":"","tags":["vim"],"title":"Vim 初级入门","uri":"/posts/how-to-use-vim/"},{"categories":null,"content":" 谓词（NSPredicate）提供在Cocoa中指定查询的普通解决方案。NSPredicate类用于定义逻辑条件以限制或筛选获取结果。\nNSPredicate 的基本使用 定义： NSPredicate *predict = [NSPredicate predicateWithFormat: @\"SELF CONTAINS[cd] %@\", SOMESTRING]; 常用方法： 关键字 效果 比较运算符 \u003e,\u003c,==,\u003e=,\u003c=,!= 左侧满足比较运算符 字符相关 BEGINSWITH 左侧表达式 以 右侧表达式 开始 ENDSWITH 左侧表达式 以 右侧表达式 结束 CONTAINS 左侧表达式包含右侧表达式 范围相关 BETWEEN 左侧表达式在右侧表达式范围内 IN 左侧表达式在右侧表达式内 正则表达式 MATCHES 左侧表达式满足右侧表达式，右侧为正则表达式 通配符 LIKE 左侧表达式等于右侧表达式: 允许将 ? 和 * 用作通配符,其中 ? 匹配一个字符,而 * 匹配零个或多个字符 字符串 NSString *originStr = @\"I like shangha!\"; NSString *str = @\"shanghai\"; NSPredicate *predict = [NSPredicate predicateWithFormat: @\"SELF CONTAINS %@\", str]; if ([predict evaluateWithObject:originStr]) { NSLog(@\"含有字符串%@\", str); } 其中 CONTAINS 也可以替换为 BEGINSWITH,ENDSWITH。 在它们后面，可以在方括号中添加c、d 或 cd, 如CONTAINS[cd],其中c代表不区分大小写, d代表不区分音调符号。\n数组和字典 谓词常用于数组的筛选:\nNSArray *mArray = [NSArray arrayWithObjects:@\"beijing\", @\"shanghai\", @\"shenzhen\", @\"guangzhou\", nil]; //IN 用法 NSPredicate *predicate1 = [NSPredicate predicateWithFormat:@\"SELF IN {'shanghai', 'guangzhou'}\"]; NSArray *filteredArray1 = [mArray filteredArrayUsingPredicate: predicate1]; NSLog(@\"筛选后数组为:%@\", filteredArray1); //LIKE 用法 NSPredicate *predicate2 = [NSPredicate predicateWithFormat:@\"SELF LIKE '*h*'\"]; NSArray *filteredArray2 = [mArray filteredArrayUsingPredicate: predicate2]; NSLog(@\"筛选后数组为:%@\", filteredArray2); 谓词的条件也可以通过字典的占位符实现:\nNSPredicate *p1 = [NSPredicate predicateWithFormat:@\"name==$NAME AND price==$PRICE\"]; NSDictionary *dic = [NSDictionary dictionaryWithObjectsAndKeys:@\"name5\", @\"NAME\", @\"5000\", @\"PRICE\", nil]; NSPredicate *p2 = [p1 predicateWithSubstitutionVariables:dic]; //表示从cars数组中筛选满足 name='name5' AND price='5000' 条件的元素 NSArray *filteredCars = [cars filteredArrayUsingPredicate:p2]; ","description":"","tags":["iOS"],"title":"NSPredicate(谓词) 的使用","uri":"/posts/predicateuse/"},{"categories":null,"content":" 什么是WebWorker\nweb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。我们知道页面的展示放在主线程，如果让主线程进行一系列复杂的操作，那么页面就会变得非常卡，用户体验会很差。这是我们可以使用web worker进行复杂操作的实现，然后将处理结果返回给页面，页面进行更新即可，这样就不会影响用户主页面展示的执行。\n方法： postMessage() : 用于向HTML页面返回消息 terminate() : 终止web worker， 并且释放资源\n实现方法： Demo: 数字从0开始累加\nindex.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cscript src=\"index.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"numDiv\"\u003e0\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e index.js var numDiv; window.onload = function() { numDiv = document.getElementById(\"numDiv\"); var worker = new Worker(\"webWorker.js\");//创建Worker对象 worker.onmessage = function (e) { numDiv.innerHTML = e.data; } } webWorker.js var countNum = 0; function count () { postMessage(countNum);//给html页面返回数据 countNum ++;//数字累加 setTimeout(count, 1000);//一秒执行一次 } count();//调用函数执行 ","description":"","tags":["HTML5","WebWorker"],"title":"HTML5 WebWorker 简单使用","uri":"/posts/html5webworker/"},{"categories":null,"content":" 什么是应用缓存？\nHTML5引入了应用缓存概念，意味着在没有因特网连接时也可以进行访问。\n使用应用缓存好处：\n离线浏览，没有因特网的情况下依然可以进行访问 访问速度提升，已经缓存的资源加载更快 减少服务器负载，浏览器只需要下载更新过的页面资源 实现方法：\n如果需要使用应用缓存，需要在页面\u003chtml\u003e标签中包含 manifest 属性，而manifest文件建议使用文件扩展名.appcache。\nManifest文件功能：\nCACHE: 在此标题下列出的文件会在首次访问加载之后进行缓存； NETWORK: 在此标题下列出的文件需要与服务器连接、且不会被缓存； FALLBACK: 在此标题下列出的文件规定当页面无法访问时的退回页面（如404页面） 功能实现 index.html 请注意\u003chtml\u003e标签 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\" manifest=\"index.appcache\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003clink rel=\"stylesheet\" href=\"style.css\"\u003e \u003cscript src=\"index.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 class=\"h1\"\u003eHELLO HMTL5\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e style.css .h1 { color: red; background: blue; } index.js /*空文件*/ index.appcache CACHE MANIFEST CACHE: index.html style.css index.js NETWORK: FALLBACK: 测试 开启本地服务器，在Chrome输入localhost/webCache\n使用Chrome审查元素功能，切换到Resources功能标签，点击左侧Application Cache功能标签，可以观察到我们设置缓存的三个文件已经缓存成功\n断开本地服务器，重新刷新页面，会发现页面样式仍然保持，说明缓存起作用了。\n","description":"","tags":["HTML5","Cache"],"title":"HTML5应用缓存简单使用","uri":"/posts/html5webcache/"},{"categories":null,"content":"前文已经介绍了如何给UITableView添加搜索栏，这次要给UITableView进一步添加索引条。 基本思路：\n获取总统名字的首字母组成一个索引字母表储存在数组中； 修改TableView的代理方法实现section的显示，section的数量应为索引字母表的元素的个数； 把索引条添加到TableView 中，用TableView的代理方法即可实现。 由于接着上文，所以本文中代码将不会全部展示，代码的重复部分将用省略号代替。\nStep1. 添加属性 在ViewController.h中添加属性：NSMutableArray *alphabetArray;\n#import \u003cUIKit/UIKit.h\u003e @interface ViewController : UIViewController ...\t@property (nonatomic, strong) NSMutableArray *alphabetArray; ...\t@end Step2. 修改ViewController.m // // ViewController.m // UITableViewAdvanced01 // // Created by mungo on 19/03/16. // Copyright © 2016 mungo. All rights reserved. // #import \"ViewController.h\" #import \"President.h\" @interface ViewController () \u003cUITableViewDataSource, UITableViewDelegate, UISearchBarDelegate, UISearchResultsUpdating, UISearchDisplayDelegate\u003e @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //初始化数据 ... //创建tableview ... //创建searchController ... //设置tableview的搜索栏 ... //设置字母表 self.alphabetArray = [self getAlphetSortedArray]; } /** * 新添加方法： * 获取字母表 * @return MSMutableArray* 已经排序的字母表数组 */ - (NSMutableArray *) getAlphetSortedArray { self.alphabetArray = [[NSMutableArray alloc] init]; for (int i = 0; i \u003c [self.presidents count]; i ++) { //获取名字的第一个字母 President *president = [self.presidents objectAtIndex:i]; char letter = [president.firstName characterAtIndex:0]; NSString *uniqueChar = [NSString stringWithFormat:@\"%c\", letter]; //将字母加入到字母表中 if (![self.alphabetArray containsObject:uniqueChar]) { [self.alphabetArray addObject:uniqueChar]; } } //对字母表进行排序 NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@\"self\" ascending:YES]; NSArray *sortDescirptors = [NSArray arrayWithObject:sortDescriptor]; NSArray *sortedArray; sortedArray = [self.alphabetArray sortedArrayUsingDescriptors:sortDescirptors]; NSMutableArray *alphabetArray = [[NSMutableArray alloc] initWithArray:sortedArray copyItems:YES]; return alphabetArray; } #pragma mark - tableView Delegate - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if (self.searchController.active) { ... } else { //根据section筛选以当前字母开头的总统数组 NSArray *tmpArray = [self getAlphabetArrayWithIndex:section]; return [tmpArray count]; } } #pragma mark - Indexing UITableView //索引条的字母表 - (NSArray\u003cNSString *\u003e *)sectionIndexTitlesForTableView:(UITableView *)tableView { return self.alphabetArray; } - (NSInteger) tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index { return index; } #pragma mark - tableView Datasource - (NSInteger) numberOfSectionsInTableView:(UITableView *)tableView { if (self.searchController.active) { self.alphabetArray = nil;//搜索时不显示section return 1; } else { self.alphabetArray = [self getAlphetSortedArray];//停止搜索恢复section显示 return [self.alphabetArray count]; } } //tableView section的标题 - (NSString *) tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section { return [self.alphabetArray objectAtIndex: section]; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { ... President *president; if (self.searchController.active) { ... } else { //根据section筛选以当前字母开头的总统数组 NSArray *tmpArray = [self getAlphabetArrayWithIndex:indexPath.section]; if ([tmpArray count]) { president = [tmpArray objectAtIndex:indexPath.row]; } } if (president) { cell.textLabel.text = [NSString stringWithFormat:@\"%@ %@\", president.firstName, president.lastName]; } return cell; } /* * 新添加方法： * 根据首字母对所有总统进行筛选 * @return NSArray* 于当前首字母相同的总统数组 */ - (NSArray *) getAlphabetArrayWithIndex:(NSInteger)index{ NSString *alphabet = [self.alphabetArray objectAtIndex:index]; NSPredicate *president = [NSPredicate predicateWithFormat:@\"firstName BEGINSWITH [cd] %@\", alphabet]; NSArray *tmpArray = [self.presidents filteredArrayUsingPredicate:president]; return tmpArray; } #pragma mark - SearchController delegate - (void)updateSearchResultsForSearchController:(UISearchController *)searchController { ... } @end 注意： numberOfSectionsInTableView中， 开始搜索的时候要将TableView的section数量设置为1，并且要把字母表设置为空；不搜索时要恢复section的数量。\n实现效果 ","description":"","tags":["iOS","UITableView"],"title":"UITableView使用简单进阶(二):索引条","uri":"/posts/uitableviewadvance02/"},{"categories":null,"content":"UITableView 是开发中使用十分频繁的控件，本系列记录UITableView的进阶使用：UITableView的搜索栏和字母索引表。\n不想看我废话的可以直接到gitHub仓库下载源码😏。 UITableView使用进阶gitHub源码\n搜索栏有两种实现方式，第一种是通过UISearchBar和UISearchDisplayController实现，第二种是通过UISearchController实现。而在iOS8.0之后，苹果官方推荐使用第二种方式。\n本文使用的是第二种方式（UISearchController），不过源码中也实现了第一种(UISearchBar+UISearchDisplayController)。关于UISearchBar和UISearchDisplayController的使用，可以参考我的另一篇文章：UISearchBar和UISearchDisplayController实现搜索栏\n本文先介绍UITableView的搜索栏（UISearchController），是一个显示美国总统的TableView。\nStep1. 创建President类 创建一个名为President的Objective-C类，它继承于NSObject类，用于保存总统的姓氏和名字。定义一个静态方法，用来创建President对象，并且对firstName和lastName赋值。\nPresident.h #import \u003cFoundation/Foundation.h\u003e @interface President : NSObject @property (nonatomic, retain) NSString *firstName; @property (nonatomic, retain) NSString *lastName; + (President *) presidentWithFirstName: (NSString *)firstname lastName: (NSString *)lastname; @end President.m #import \"President.h\" @implementation President + (President *) presidentWithFirstName:(NSString *)firstname lastName:(NSString *)lastname { President *president = [[President alloc] init]; president.firstName = firstname; president.lastName = lastname; return president; } @end Step2. 编写ViewController viewController.h #import \u003cUIKit/UIKit.h\u003e @interface ViewController : UIViewController @property (nonatomic, strong) UITableView *mTableView; @property (nonatomic, strong) NSArray *presidents;//所有总统 @property (nonatomic, strong) NSArray *filteredPresidents;//保存搜索结果 @property (nonatomic, retain) UISearchController *searchController;\t@end viewController.m #import \"ViewController.h\" #import \"President.h\" @interface ViewController () \u003cUITableViewDataSource, UITableViewDelegate, UISearchBarDelegate, UISearchResultsUpdating, UISearchDisplayDelegate\u003e @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //初始化数据 self.presidents = [[NSArray alloc] initWithObjects: [President presidentWithFirstName:@\"George\" lastName:@\"Washington\"], [President presidentWithFirstName:@\"John\" lastName:@\"Adams\"], [President presidentWithFirstName:@\"Thomas\" lastName:@\"Jeffeson\"], [President presidentWithFirstName:@\"James\" lastName:@\"Madison\"], [President presidentWithFirstName:@\"James\" lastName:@\"Monroe\"], [President presidentWithFirstName:@\"John Quincy\" lastName:@\"Adams\"], [President presidentWithFirstName:@\"Andrew\" lastName:@\"Jackson\"], [President presidentWithFirstName:@\"Martin\" lastName:@\"van Buren\"], [President presidentWithFirstName:@\"William Henry\" lastName:@\"Harrison\"], [President presidentWithFirstName:@\"John\" lastName:@\"Tyler\"], [President presidentWithFirstName:@\"James K\" lastName:@\"Polk\"], [President presidentWithFirstName:@\"Zachary\" lastName:@\"Taylor\"], [President presidentWithFirstName:@\"Millard\" lastName:@\"Fillmore\"], [President presidentWithFirstName:@\"Franklin\" lastName:@\"Pierce\"], [President presidentWithFirstName:@\"James\" lastName:@\"Buchanan\"], [President presidentWithFirstName:@\"Abraham\" lastName:@\"Lincoln\"], [President presidentWithFirstName:@\"Andrew\" lastName:@\"Johnson\"], [President presidentWithFirstName:@\"Ulysses S\" lastName:@\"Grant\"], [President presidentWithFirstName:@\"Rutherford B\" lastName:@\"Hayes\"], [President presidentWithFirstName:@\"James A\" lastName:@\"Garfield\"], [President presidentWithFirstName:@\"Chester A\" lastName:@\"Arthur\"], [President presidentWithFirstName:@\"Grover\" lastName:@\"Cleveland\"], [President presidentWithFirstName:@\"Bejamin\" lastName:@\"Harrison\"], [President presidentWithFirstName:@\"Grover\" lastName:@\"Cleveland\"], [President presidentWithFirstName:@\"William\" lastName:@\"McKinley\"], [President presidentWithFirstName:@\"Theodore\" lastName:@\"Roosevelt\"], [President presidentWithFirstName:@\"William Howard\" lastName:@\"Taft\"], [President presidentWithFirstName:@\"Woodrow\" lastName:@\"Wilson\"], [President presidentWithFirstName:@\"Warren G\" lastName:@\"Harding\"], [President presidentWithFirstName:@\"Calvin\" lastName:@\"Coolidge\"], [President presidentWithFirstName:@\"Herbert\" lastName:@\"Hoover\"], [President presidentWithFirstName:@\"Franklin D\" lastName:@\"Roosevelt\"], [President presidentWithFirstName:@\"Harry S\" lastName:@\"Truman\"], [President presidentWithFirstName:@\"Dwight D\" lastName:@\"Eisenhower\"], [President presidentWithFirstName:@\"John F\" lastName:@\"Kennedy\"], [President presidentWithFirstName:@\"Lyndon B\" lastName:@\"Johnson\"], [President presidentWithFirstName:@\"Richard\" lastName:@\"Nixon\"], [President presidentWithFirstName:@\"Gerald\" lastName:@\"Ford\"], [President presidentWithFirstName:@\"Jimmy\" lastName:@\"Carter\"], [President presidentWithFirstName:@\"Ronald\" lastName:@\"Reagan\"], [President presidentWithFirstName:@\"George H W\" lastName:@\"Bush\"], [President presidentWithFirstName:@\"Bill\" lastName:@\"Clinton\"], [President presidentWithFirstName:@\"George W\" lastName:@\"Bush\"], [President presidentWithFirstName:@\"Barack\" lastName:@\"Obama\"], nil]; CGRect appFrame = [[UIScreen mainScreen] bounds]; //创建tableview self.mTableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, appFrame.size.width, appFrame.size.height - 20) style:UITableViewStylePlain]; self.mTableView.delegate = self; self.mTableView.dataSource = self; [self.view addSubview:self.mTableView]; //创建searchController self.searchController = [[UISearchController alloc] initWithSearchResultsController:nil]; self.searchController.searchResultsUpdater = self; self.searchController.dimsBackgroundDuringPresentation = NO; self.searchController.hidesNavigationBarDuringPresentation = NO; //设置tableview的搜索栏 self.mTableView.tableHeaderView = self.searchController.searchBar; } #pragma mark - tableView Delegate - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if (self.searchController.active) { return [self.filteredPresidents count]; } else { return [self.presidents count]; } } #pragma mark - tableView Datasource - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *cellId = @\"cellId\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellId]; if (!cell) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId]; } President *president; if (self.searchController.active) { president = [self.filteredPresidents objectAtIndex:indexPath.row]; } else { president = [self.presidents objectAtIndex:indexPath.row]; } cell.textLabel.text = [NSString stringWithFormat:@\"%@ %@\", president.firstName, president.lastName]; return cell; } #pragma mark - SearchController delegate - (void)updateSearchResultsForSearchController:(UISearchController *)searchController { NSString *searchString = [self.searchController.searchBar text]; NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"firstName CONTAINS[cd] %@ OR lastName CONTAINS[cd] %@\", searchString, searchString]; self.filteredPresidents = [self.presidents filteredArrayUsingPredicate:predicate]; //刷新表格 [self.mTableView reloadData]; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } @end 实现效果 ","description":"","tags":["iOS","UITableView","搜索栏"],"title":"UITableView使用简单进阶(一):搜索栏","uri":"/posts/uitableviewadvanced01/"},{"categories":null,"content":"要实现tableview的搜索栏，实现方法有两种：第一种是UISearchBar和UIDisplayController结合起来实现，另一种是通过UISearchController实现。这里只介绍第一种：\n注意: UISearchBar和UISearchDisplay只推荐iOS8.0之前使用。 关于UISearchController的使用请跳转至： UITableView使用进阶(一):搜索栏\n使用的协议 需要使用四个协议，分别是\n\u003cUITableViewDelegate, UITableViewDataSource, UISearchBarDelegate, UISearchDisplayDelegate\u003e\n头文件 ViewController.h #import \u003cUIKit/UIKit.h\u003e @interface ViewController : UIViewController @property (nonatomic, strong) UITableView *mTableView; //搜索结果 @property (nonatomic, strong) NSArray *filterData; //全部数据 @property (nonatomic, strong) NSMutableArray *allData; @property (nonatomic, retain) UISearchDisplayController *searchDisplayController; @end 实现文件 ViewController.m #import \"ViewController.h\" @interface ViewController () \u003cUITableViewDelegate, UITableViewDataSource, UISearchBarDelegate, UISearchDisplayDelegate\u003e @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; //初始化数据 int count = 100; self.allData = [NSMutableArray arrayWithCapacity:count]; for (int i = 0; i \u003c count; i ++) { [self.allData addObject:[NSString stringWithFormat:@\"第%d行\", i]]; } //定义tableview CGRect appFrame = [[UIScreen mainScreen] bounds]; self.mTableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 20, appFrame.size.width, appFrame.size.height - 20) style:UITableViewStylePlain]; self.mTableView.delegate = self; self.mTableView.dataSource = self; [self.view addSubview:self.mTableView]; //定义UISearchBar UISearchBar *mySearchBar = [[UISearchBar alloc] init]; mySearchBar.delegate = self; [mySearchBar setAutocapitalizationType:UITextAutocapitalizationTypeNone]; [mySearchBar sizeToFit]; self.mTableView.tableHeaderView = mySearchBar; //定义UISearchDisplayController self.searchDisplayController = [[UISearchDisplayController alloc] initWithSearchBar:mySearchBar contentsController:self]; self.searchDisplayController.delegate = self; [self.searchDisplayController setSearchResultsDataSource:self]; [self setSearchDisplayController:self.searchDisplayController]; } #pragma mark - UITableView Delegate - (NSInteger) numberOfSectionsInTableView:(UITableView *)tableView { return 1; } - (NSInteger) tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { if (tableView == self.searchDisplayController.searchResultsTableView) { return [self.filterData count]; } else { return [self.allData count]; } } #pragma mark - UITableView DataSource - (UITableViewCell *) tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *cellid = @\"cellid\"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellid]; if (!cell) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellid]; } if (tableView == self.searchDisplayController.searchResultsTableView) { cell.textLabel.text = [self.filterData objectAtIndex:indexPath.row]; } else { cell.textLabel.text = [self.allData objectAtIndex:indexPath.row]; } return cell; } #pragma mark - UISearchDisplayController - (BOOL) searchDisplayController:(UISearchDisplayController *)controller shouldReloadTableForSearchString:(NSString *)searchString { NSPredicate *predicate = [NSPredicate predicateWithFormat:@\"SELF CONTAINS[cd] %@\", searchString]; self.filterData = [self.allData filteredArrayUsingPredicate:predicate]; return YES; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } @end 实现效果 ","description":"","tags":["iOS","UITableView","搜索栏"],"title":"UISearchBar和UISearchDisplayController实现搜索栏","uri":"/posts/uisearchbar-uisearchdisplaycontroller/"},{"categories":null,"content":"- (UIImage *) stretchableImageWithLeftCapWidth:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight 这个函数是UIImage的一个类函数，它的功能是创建一个内容可拉伸，而边角不拉伸的图片。两个参数的含义分别为：不拉伸区域的宽度、不拉伸区域的高度。\n根据设置的宽度和高度，在像素点((leftCapWidth+1), (topCapWidth+1))开始左右扩展和上下拉伸。\n注意： 可拉伸范围是距离leftCapWidth+1的那一列像素和topCapHeight+1的那一横排像素。 如果设置参数为10和5，那么，图片左边10个像素和上边5个像素区域内不会被拉伸。而从(11, 5)开始扩展和拉伸。\n只是对一个像素进行复制到一定宽度，而图像后面的剩余部分也不会被拉伸。\n//原始图片 UIImage *image = [UIImage imageNamed:@\"yoububble.png\"] ; UIImageView *imageView1 = [[UIImageView alloc] initWithImage:image]; [imageView1 setFrame:CGRectMake(10, 60, 40, 40)]; [self.view addSubview:imageView1]; //拉伸后图片 UIImage *strechImage = [image stretchableImageWithLeftCapWidth:10 topCapHeight:10]; UIImageView *imageView2 = [[UIImageView alloc] initWithImage:strechImage]; [imageView2 setFrame:CGRectMake(10, 120, 300, 100)]; [self.view addSubview:imageView2]; ","description":"","tags":["iOS"],"title":"stretchableImageWithLeftCapWith:(NSInteger)leftCapWidth topCapHeight:(NSInteger)topCapHeight","uri":"/posts/stretchableimagewithleftcapwidth/"},{"categories":null,"content":"- (UILabel *) getLabelHeightFixedWithText: (NSString *) text { UIFont *font = [UIFont boldSystemFontOfSize: 12.0f]; int width = 225, height = 10000; NSMutableDictionary *attrs = [[NSMutableDictionary alloc] init]; [attrs setObject: font forKey: NSFontAttributeName]; CGRect size = [text boundingRectWithSize:CGSizeMake(width, height) options: NSStringDrawingUsesLineFragmentOrigin attributes: attrs context: nil]; UILabel *label = [[UILabel alloc] initWithFrame: CGRectMake(0, 0, size.size.width, size.size.height)]; label.numberOfLines = 0;//一定要设置行数为0 label.font = font; label.lineBreakMode = NSLineBreakByWordWrapping; label.text = (text ? text : @\"\"); label.backgroundColor = [UIColor clearColor]; label.textColor = [UIColor blackColor]; return label; } ","description":"","tags":["iOS","UILabel"],"title":"根据字数自适应高度的UILabel","uri":"/posts/uilabel-with-height-fixed/"},{"categories":null,"content":"简介 在编写Web程序时，表单的提交若密码使用明文提交会十分不安全，因此在浏览器端也要对密码进行加密处理。但是若只是在浏览器端处理了，而服务器没有再一次加密，也是不妥当的，因为\"中间人\"只要获取了浏览器端加密的密码，不需要进行处理也能进行登录。所以我一般的做法是在前端加密一次，在服务器再加密一次。密码加盐（salt）的问题等我先研究下再写一下。而浏览器端加密一般我都用javascript进行加密后再提交。下面是用javascript编写的base64加密，md5加密和sha1加密。使用方法也极其简单，只要在页面内引入相应js文件即可。\nbase64加解密 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ebase64加解密\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"base64.js\"\u003e\u003c/script\u003e \u003cscript\u003e var base64 = new Base64(); //加密 var base64encodeStg = base64.encode(\"hello world!\"); alert(\"base64encode:\" + base64encodeStg); //解密 var base64decodeStg = base64.decode(base64encodeStg); alert(\"base64decode:\" + base64decodeStg); \u003c/script\u003e \u003c/head\u003e \u003c/html\u003e md5加密 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003emd5加密\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"md5.js\"\u003e\u003c/script\u003e \u003cscript\u003e var hash = hex_md5(\"hello world!\"); alert(hash);\t\u003c/script\u003e \u003c/head\u003e \u003c/html\u003e sha1加密 相对于前两个，sha1加密可能更安全\n\u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003esha1加密\u003c/title\u003e \u003cscript type=\"text/javascript\" src=\"sha1.js\"\u003e\u003c/script\u003e \u003cscript\u003e var sha1 = hex_sha1(\"hello world!\"); alert(sha1); \u003c/script\u003e \u003c/head\u003e \u003c/html\u003e 相关文件下载 base64.js | md5.js | sha1.js 百度网盘分享\n","description":"","tags":["md5","base64","sha1","javascript","加密"],"title":"JS实现密码加密(base64, md5, sha1)","uri":"/posts/javascript-md5-base64-sha1/"},{"categories":null,"content":"站长之家（ChinaZ.com） 3月4日消息，昨日开始，国内知名图床服务网站贴图库首页和服务器部分地区出现了无法访问的情况。据站长之家了解，贴图库因被检测到非法内容，遭到网信办下令要求域名服务商易名中国将域名**clientHold（锁定）**处理。\n我博客上面的图片也全都放在贴图库上面的，今天刚回归博客就发现图片不能访问了。查过之后才贴图库被关闭了，不过我觉得官方应该能解决好这个事情，毕竟是国内知名图床服务网站，用户数量应该很多。我觉得会给用户一个满意的答复的。要不然我博客里面的图片怎么办啊。摔！\n","description":"","tags":["贴图库","网信办","记录"],"title":"贴图库被网信办关闭 官方：解决需要时间","uri":"/posts/tietuku-clienthold/"},{"categories":null,"content":"为了使保存的密码更安全， 我们应该实现一个NSString的分类，为密码创建一个MD5的哈希值，而且并把它保存在keychain中；keychain是在设备中保存关键数据的唯一安全的地方。\nstep1. 新建文件 新建文件，在模板列表中选择Objective-C Category项。单击Next按钮，输入“MD5”作为这个创建的分类的名字，然后在CategoryOn下拉菜单中选择NSString，表明是NSString的Category。\nstep2. 头文件 #import \u003cFoundation/Foundation.h\u003e @interface NSString (MD5) - (NSString *) MD5; @end step3. 源文件 #import \"NSString+MD5.h\" #import \u003cCommonCrypto/CommonDigest.h\u003e @implementation NSString (MD5) - (NSString *) MD5{ //转化为UTF8格式字符串 const char *ptr = [self UTF8String]; //开辟一个16字节数组 unsigned char md5Buffer[CC_MD5_DIGEST_LENGTH]; //调用官方封装的加密方法, 将ptr开始的字符串存储到md5Buffer[]中 CC_MD5(ptr, strlen(ptr), md5Buffer); //转换位NSString并返回 NSMutableString *output = [NSMutableString stringWithCapacity: CC_MD5_DIGEST_LENGTH * 2]; for (int i = 0; i \u003c CC_MD5_DIGEST_LENGTH; i ++) { [output appendFormat: @\"%02x\", md5Buffer[i]]; } /* * `x`表示十六进制，%02 意思是不足两位用0补齐，如果多于2位则不影响 * NSLog(\"%02x\", 0x666); //输出 `666` * NSLog(\"%02x\", 0x3);\t//输出 `03` */ return output; } @end ","description":"","tags":["iOS","加密","MD5"],"title":"iOS NSString字符串MD5加密","uri":"/posts/ios-md5/"},{"categories":null,"content":"之前从接口获取数据后转换为NSDictionary然后执行writeToFile就可以写入文件成功，昨天在使用豆瓣电影Api时，出现了前几条请求的数据写入缓存成功，从某一次请求开始就总是写入不成功。因为我是用gcd方式请求数据的，我还以为是因为线程竞争的问题，但是写文件的原子操作我设置的YES啊。然后写进程锁试一下，然而仍然写入失败，后来我不用gcd以为能好，结果还是写入失败。后来翻资料，说好像如果NSDictionary中有自定义的object类型是不能写入文件的，比如像null，呵呵。但是我找了半天也没找到错误所在，然后也不太影响正常使用，就暂时放在一边了。\n结果今天出问题了，之前获取的是电影的列表信息，今天要写电影的详情页信息。写好后不断测试，结果有一条电影，一点进入详情就会崩溃。好了，设置好断点，一步步排查，最后NSLog导演头像的urlString时，找到了问题所在，导演的头像图片的url为null！终于找到了问题所在。那么可以解决了…\n我获取了该条目电影的id号，然后在浏览器中获取了他的json数据，果不其然，就是这个电影!《火云端》!\n然而我并没有想到有这么多null。\n经过百度，好像要写文件，NSDictionary里面的object必须是NSString，NSData，NSNumber，NSDate，NSArray，NSDictionary中的数据类型。不过我知道，含有null是万万不能的，混蛋。\n解决方案：NSDictionary -\u003e NSDate NSDictionary写文件之前，可以把它转换成NSData类型的数据，再执行写文件操作。 从文件读取时把读取出的NSData转换为NSDictionary就可以了。\n用到的方法 NSDictionary -\u003e NSData:\nNSData *data = [NSKeyedArchiver archivedDataWithRootObject:dictionary]; NSData -\u003e NSDictionary:\nNSDictionary *dictionary = (NSDictionary *)[NSKeyedUnarchiver unarchiveObjectWithData:data]; 昨天的问题解决了，这样写时候，每一次都能写入缓存文件成功。\n今天的涉及到NSDictionary值的获取的部分，我都加了一个判断 if([theValue isKindOfClass:[NSNull class]])，然后进行相应处理就可以了。\n这个时iOS的一个归档方法，不仅仅能归档null，自定义的类型也是可以的。具体可以参见小白猪jianjian的博客-使用NSKeyedArchiver归档\n感想 生活中或者程序开发中，遇到了问题不一定非要立马解决，如果死钻牛角尖儿可能一直都解决不了，那时只能浪费时间。如果暂时放放，休息一会，再回来想解决办法可能就能想到解决方案。就像今天我解决我的问题一样，完全是机缘巧合。同时我们也应该发现，如果想做出好的软件，前期开发的投入很重要，但是后期的测试也很重要。功能做完之后我也是点击测试了不说几百次，几十次也是有了才发现了这个问题。\n最后给大家看下我做的电影影讯，嘿嘿，使用了豆瓣电影Api。\n","description":"","tags":["iOS"],"title":"NSDictionary含有null导致写文件(writeToFile)失败(豆瓣电影Api返回Json数据中含有null)","uri":"/posts/nsdictionarywritetofilefailedbecauseofcontainsnull/"},{"categories":null,"content":"上一篇已经实现了页面的布局，这一篇我们来实现界面的逻辑变换。主要用到的是scollView的两个代理方法。我们先看一下效果。\n1.实现点击顶部按钮切换底部详情页面 给顶部items的按钮添加target 在- (void) addFirstScrollViewOnView 方法中的for循环中，为每个button添加一个target，用于监听点击按钮的事件。\n[itemButton addTarget:self action:@selector(itemButtonClicked:) forControlEvents:UIControlEventTouchUpInside]; 添加监听方法 我们应该知道当点击顶部item按钮时，底部详情页应该做相应的切换，同时按钮样式也改变。 大家可能注意到了需要用到按钮的tag值，所以我们同样在上一步的方法的for循环中为每个按钮设置tag值。\nitemButton.tag = 100 + i;//设置button的tag值 同时，需要添加一个实例变量：\n//记录当前被点击的按钮tag @property (nonatomic, assign) NSInteger currentButtonTag; **(重要)**并在上一步方法的最后为它设置初始值为100，也就是当前点击的按钮为第一个。\ntips：不从1开始设置tag值的原因是因为前100可能有系统的控件占用 scrollView详情页切换：获取当前按钮的tag值，计算偏移量\n- (void) itemButtonClicked:(UIButton *)button { //**1.偏移底部详情scrollView NSInteger buttonTag = button.tag - 100;//获取点击按钮的tag self.secondScrollView.contentOffset = CGPointMake(buttonTag * KSCREEN_WIDTH, 0);//设置底部scrollview的内容偏移量 //**2.恢复前一个被点击的按钮的样式 UIButton *preClickedButton = (UIButton *)[self.view viewWithTag:self.currentButtonTag]; preClickedButton.titleLabel.font = [UIFont systemFontOfSize:14.0f]; [preClickedButton setTitleColor:[UIColor colorWithRed:0.4 green:0.4 blue:0.4 alpha:1.0] forState:UIControlStateNormal];//标题颜色 //**3.设置当前点击按钮样式 button.titleLabel.font = [UIFont systemFontOfSize:18.0f]; [button setTitleColor:[UIColor colorWithRed:1.0 green:0.3 blue:0.3 alpha:1.0f] forState:UIControlStateNormal]; //**4.改变当前点击按钮的tag值 self.currentButtonTag = buttonTag + 100; } 完成这一步，当你点击顶部按钮的时候，你就可以看到顶部按钮样式的改变和底部详情页面的切换。\n2.实现滚动底部详情页顶部按钮字体切换 添加scrollView的代理 添加代理\n@interface ViewController () \u003cUIScrollViewDelegate\u003e 在- (void) addSecondScrollViewOnView 方法中设置secondScrollView的代理为self。这步不要忘记了。\nsecondScrollView.delegate = self; 实现scrollView 的代理方法 - (void) scrollViewDidScroll:(UIScrollView *)scrollView； 在这一步，我们要实现滚动时，顶部items的按钮字体大小和颜色的改变。\n//正在滑动调用的代理方法 - (void) scrollViewDidScroll:(UIScrollView *)scrollView { //获取当前第二个scrollView的偏移量 CGFloat secondScrollViewContentOffsetX = scrollView.contentOffset.x; //获取选中按钮的序号 int buttonTag = (secondScrollViewContentOffsetX) / KSCREEN_WIDTH; //计算手指滑动了多少距离 CGFloat fingerDistance = secondScrollViewContentOffsetX - KSCREEN_WIDTH * buttonTag; //获取到下一个按钮，并改变其字体大小和颜色，逐渐放大（根据手指滑动的距离动态改变） UIButton *buttonNext = (UIButton *)[self.view viewWithTag:(buttonTag + 100 + 1)]; buttonNext.titleLabel.font = [UIFont systemFontOfSize:(14.0 + fingerDistance * 4 / (KSCREEN_WIDTH))]; [buttonNext setTitleColor:[UIColor colorWithRed:(0.4f + 3 * fingerDistance / (KSCREEN_WIDTH * 5)) green:0.3 blue:0.3 alpha:1.0] forState:UIControlStateNormal]; //同样方法获取到当前按钮，并改变其字体大小和颜色恢复回原来样式，逐渐缩小（根据手指滑动的距离动态改变） UIButton *buttonCurr = (UIButton *)[self.view viewWithTag:(buttonTag + 100)]; buttonCurr.titleLabel.font = [UIFont systemFontOfSize:(18.0 - fingerDistance * 4 / (KSCREEN_WIDTH))]; [buttonCurr setTitleColor:[UIColor colorWithRed:(1.0f - 3 * fingerDistance / (KSCREEN_WIDTH * 5)) green:0.3 blue:0.3 alpha:1.0] forState:UIControlStateNormal]; } 这里可以看到下一个按钮的字体动态改变，计算方法其实非常简单。 设手指滑动距离为x，字体大小为y。那么我们有两个值 (0,14), (KSCREEN_WIDTH, 18)。 然后列二元一次方程组，就可以得到 a 和 b。 我这里解得 a = 4/KSCREEN_WIDTD , b = 14\n当前按钮的改变亦然。只是两个点变为 (KSCREEN_WIDTH, 14), (0, 18) 计算得到 a = －(4/KSCREEN_WIDTH), b = 18\n颜色大家计算方式相似，不再赘述。\n3.使顶部scrollView随底部scrollView滑动而滚动 我们注意看网易新闻客户端，它底部scrollView滚动之后，顶部的scrollView也会随之滚动，并且除了开头或者末尾的几个按钮，它当前所在的新闻类型始终在屏幕中间。并且顶部的滚动总是在底部滑动结束之后，所以我们实现scrollView的代理方法\t- (void) scrollViewDidEndDecelerating:(UIScrollView *)scrollView //滑动结束调用的代理方法 - (void) scrollViewDidEndDecelerating:(UIScrollView *)scrollView { //**1.获取选中详情页对应的顶部button //移动顶部选中的按钮 CGFloat secondScrollViewContentOffsetX = scrollView.contentOffset.x; //获取选中按钮的序号 int buttonTag = (secondScrollViewContentOffsetX) / KSCREEN_WIDTH; //根据按钮号码获取到顶部的按钮 UIButton *buttonCurr = (UIButton *)[self.view viewWithTag:(buttonTag + 100)]; //**2.(重要)设置当前选中的按钮号。如若不写，将导致滑动后再点击顶部按钮，上一个按钮颜色，字体不会改变 self.currentButtonTag = buttonTag + 100; //**3.始终保持顶部选中按钮在中间位置 //注意一：开始的几个按钮，和末尾的几个按钮并不需要一直保持中间。 //注意二：对于已经放置在firstScrollView中的按钮，它的center是相对于scrollView的content而言的，注意并不是相对于self.view的bounds而言的。也就是说，放置好按钮，它的center就不会再改变 //如果是顶部scrollView即将到末尾的几个按钮，设置偏移量，直接return if (buttonCurr.center.x + KSCREEN_WIDTH * 0.5 \u003e self.firstScrollView.contentSize.width) { [UIView animateWithDuration:0.3 animations:^{ self.firstScrollView.contentOffset = CGPointMake(self.firstScrollView.contentSize.width - KSCREEN_WIDTH, 0); }]; return; } //如果是顶部scrollView开头的几个按钮，设置偏移量，直接return if (buttonCurr.center.x \u003c KSCREEN_WIDTH * 0.5) { [UIView animateWithDuration:0.3 animations:^{ self.firstScrollView.contentOffset = CGPointMake(0, 0); }]; return; } //如果是中间几个按钮的情况 if (buttonCurr.center.x \u003e (KSCREEN_WIDTH * 0.5)) { [UIView animateWithDuration:0.3 animations:^{ self.firstScrollView.contentOffset = CGPointMake(buttonCurr.center.x - self.view.center.x, 0); }]; } } 这里需要注意的是我注释里面的第2步和第3步。 第2步一定要写，否则导致先滑动底部scrollView，再点击顶部scrollView的button，出现之前的那个button样式不恢复的情况。 第3步，注意前几个按钮和后几个按钮位置的判断，如果一味保持按钮在中间，就会出现顶部的offset过多，而后面出现空白，大家可以简单尝试一下。\n整个效果就已经完成了～☺️\n","description":"","tags":["iOS"],"title":"纯代码高仿网易新闻客户端两个scrollView联动（二）：实现界面逻辑变换","uri":"/posts/twoscrollviewlinkage-2-businesslogic/"},{"categories":null,"content":"自己再开发app过程中遇到了这样那样的需求，其中有一项是新闻页面，需要两个scrollView联动，上面的scrollView是新闻类型，下面scrollView是tableView新闻标题。开发过程中我全部都是用代码布局的，因为自己是新手，不知道到底是用代码写比较方便还是用storyBoard更方便，但是感觉手写代码适应屏幕上更容易上手吧。需求实现之后现在拿出来简单整理一下，方便自己日后查看，也给后来者以参考。因为刚刚开始学，用到的都是些简单的方法，也可能会出错，如果有什么不足，请留言给我指出。谢谢～\n现在开始正题： 本文是第一篇，先是简单的页面布局，首先我们看一下布局之后的效果：\n1.宏定义 //屏幕的宽和高 #define KSCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height #define KSCREEN_WIDTH [UIScreen mainScreen].bounds.size.width //最顶部状态栏的高度 #define KSTATUS_HEIGHT 20 //顶部items的scrollView的高度 #define KFIRST_SCROLLVIEW_HEIGHT 30 //根据计算，得到底部详情scrollView的高度 #define KSECOND_SCROLLVIEW_HEIGHT (KSCREEN_HEIGHT - KSTATUS_HEIGHT - KFIRST_SCROLLVIEW_HEIGHT) //顶部scrollView每个item按钮的宽度 #define KFIRST_SCROLLVIEW_ITEM_WIDTH 55 2.首先定义需要用到的变量 @interface ViewController () //顶部items的scrollView @property (nonatomic, weak) UIScrollView *firstScrollView; //底部详情scrollView @property (nonatomic, weak) UIScrollView *secondScrollView; //item类型的数组 @property (nonatomic, strong) NSArray *itemsTitlesArray; //为了方便，定义一个包含颜色的NSArray（自行取舍） @property (nonatomic, strong) NSArray *colorArray; @end 3.懒加载 #pragma mark - lazy load //定义items的标题 - (NSArray *) itemsTitlesArray { if (!_itemsTitlesArray) { _itemsTitlesArray = [NSArray arrayWithObjects:@\"热点新闻\", @\"新闻快讯\", @\"通知公告\", @\"院系通知\", @\"人物风采\", nil]; } return _itemsTitlesArray; } //颜色数组 - (NSArray *) colorArray { if (!_colorArray) { _colorArray = [NSArray arrayWithObjects: [UIColor colorWithRed:240.0/255.0 green:89.0/255.0 blue:136.0/255.0 alpha:1.0], [UIColor colorWithRed:0.0/255.0 green:179.0/255.0 blue:155.0/255.0 alpha:1.0], [UIColor colorWithRed:244.0/255.0 green:131.0/255.0 blue:69.0/255.0 alpha:1.0], [UIColor colorWithRed:241.0/255.0 green:90.0/255.0 blue:102.0/255.0 alpha:1.0], [UIColor colorWithRed:0.0/255.0 green:179.0/255.0 blue:155.0/255.0 alpha:1.0], [UIColor colorWithRed:255.0/255.0 green:223.0/255.0 blue:104.0/255.0 alpha:1.0], nil]; } return _colorArray; } 4.添加顶部items的scrollView //添加第一个scrollview - (void) addFirstScrollViewOnView { //**1.设置顶部类型scrollView UIScrollView *firstScrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, KSTATUS_HEIGHT, KSCREEN_WIDTH, KFIRST_SCROLLVIEW_HEIGHT)]; firstScrollView.bounces = NO;//禁止反弹 firstScrollView.showsHorizontalScrollIndicator = NO;//禁止显示水平滚动条 //设置scrollView的内容大小，宽度为 宏定义顶部按钮的宽度 ＊ items数组的数量 firstScrollView.contentSize = CGSizeMake(self.itemsTitlesArray.count * KFIRST_SCROLLVIEW_ITEM_WIDTH, KFIRST_SCROLLVIEW_HEIGHT); self.firstScrollView = firstScrollView; [self.view addSubview:firstScrollView];//添加到self.view //**2.为第一个scrollView添加buttons for (int i = 0; i \u003c self.itemsTitlesArray.count; i ++) { UIButton *itemButton = [[UIButton alloc] initWithFrame:CGRectMake(i * KFIRST_SCROLLVIEW_ITEM_WIDTH, 0, KFIRST_SCROLLVIEW_ITEM_WIDTH, KFIRST_SCROLLVIEW_HEIGHT)];//注意左边距的写法 [itemButton setTitle:[self.itemsTitlesArray objectAtIndex:i] forState:UIControlStateNormal];//标题 itemButton.backgroundColor = [UIColor colorWithRed:0.97 green:0.97 blue:0.97 alpha:1.0];//背景颜色 [itemButton setTitleColor:[UIColor colorWithRed:0.4 green:0.4 blue:0.4 alpha:1.0] forState:UIControlStateNormal];//标题颜色 itemButton.titleLabel.font = [UIFont systemFontOfSize:14.0]; [firstScrollView addSubview:itemButton];//添加到第一个scrollView //定义第一个顶部item的按钮样式 if (i == 0) { itemButton.titleLabel.font = [UIFont systemFontOfSize:18.0f]; [itemButton setTitleColor:[UIColor colorWithRed:1.0 green:0.3 blue:0.3 alpha:1.0f] forState:UIControlStateNormal]; } } } 5.添加底部详情scrollView //添加第二个scrollview - (void) addSecondScrollViewOnView { //**1.设置底部详情scrollView UIScrollView *secondScrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, KSTATUS_HEIGHT + KFIRST_SCROLLVIEW_HEIGHT, KSCREEN_WIDTH, KSECOND_SCROLLVIEW_HEIGHT)]; secondScrollView.pagingEnabled = YES;//分页 secondScrollView.bounces = NO;//禁止反弹 secondScrollView.delegate = self; //设置内容大小，宽度为 屏幕的宽度 * items数组的数量 secondScrollView.contentSize = CGSizeMake(self.itemsTitlesArray.count * KSCREEN_WIDTH, KSECOND_SCROLLVIEW_HEIGHT); self.secondScrollView = secondScrollView; [self.view addSubview:secondScrollView]; //**2.添加Views for (int i = 0; i \u003c self.itemsTitlesArray.count; i ++) { UIView *bottomView = [[UIView alloc] initWithFrame:CGRectMake(i * KSCREEN_WIDTH, 0, KSCREEN_WIDTH, KSECOND_SCROLLVIEW_HEIGHT)]; bottomView.backgroundColor = [self.colorArray objectAtIndex:(i % 6)];//颜色数组取余 //为了方便观察，放置一个label，如果需要其它控件自行替换（如若新闻，用tableView） UILabel *flagLabel = [[UILabel alloc] initWithFrame:bottomView.bounds]; flagLabel.font = [UIFont systemFontOfSize:50.0f]; flagLabel.textColor = [UIColor whiteColor]; flagLabel.textAlignment = NSTextAlignmentCenter; flagLabel.text = [NSString stringWithFormat:@\"%@\", [self.itemsTitlesArray objectAtIndex:i]]; [bottomView addSubview:flagLabel]; [secondScrollView addSubview:bottomView]; } } 6.在-(void)viewDidLoad方法中调用两个添加scrollView的方法 - (void)viewDidLoad { [super viewDidLoad]; [self addFirstScrollViewOnView];//添加顶部items的scrollView [self addSecondScrollViewOnView];//添加底部详情的scrollView } 7.声明 本文涉及的一切代码，都将上传到我的github仓库:https://github.com/Gitzhaoyang/iOSWithOC/tree/master/twoScrollViewLinkage，请自行查看。\n","description":"","tags":["iOS"],"title":"纯代码高仿网易新闻客户端两个scrollView联动（一）：设置基本的界面布局","uri":"/posts/twoscrollviewlinkage-1-baseview/"},{"categories":null,"content":"实现原理十分简单，使用UIImageView的透明度即可。然后在动画中完成。 alpha = 1 为全透明。 运行图例：\n实现代码:\n//图片渐隐渐现 self.backgroundView.alpha = 0.7; [UIView animateWithDuration:0.5 animations:^{ self.backgroundView.alpha = 1; self.backgroundView.image = [UIImage imageNamed:@\"weather_bg_02.jpg\"]; }]; 后来我知道了可以用更好的方法实现， 后续会有更新\n","description":"","tags":["iOS"],"title":"UIImageView更换图片时渐隐渐现","uri":"/posts/uiimageview-image-fade-out/"},{"categories":null,"content":"一开始自己将tabBar全部自定义，将系统tabbar设置为self.tabBar.hidden=YES，隐藏系统的tabbar。但是自定义的tabbar在push出新页面的时候，tabbar并不会自动隐藏。之后在新页面viewWillAppear中设置自动隐藏，但是pop回之前页面（在viewDidAppear中设置tabbar显示）又出现不能及时出现，会有时间延迟，看上去特别不舒服。而且，边缘返回旧页面的时候不能及时显示tabbar也，所以打算用系统默认的tabbar。记录下系统tabBar样式的简单定义。\n简单自定义系统的tabBar - (void) initTabBarView { NSArray *titles = @[@\"工大威海\", @\"校园应用\", @\"校园生活\", @\"更多功能\"]; //tabBarItem选中图片简单颜色变化时，自定义选中后的颜色 [self.tabBar setTintColor:[UIColor redColor]]; int i = 0; for (UITabBarItem *item in self.tabBar.items) { //自定义tabBarItem的图片 item.image = [[UIImage imageNamed: [NSString stringWithFormat:@\"home_tab_icon_%d\", i + 1]] imageWithRenderingMode:UIImageRenderingModeAutomatic]; //定义选中图片,上面imageWithRederingMode设置为Automatic，只是简单颜色变换，不需要设置,不再赘述 //item.selectedImage = .... //设置tabBarItem的标题 item.title = titles[i]; i ++; } } 这是运行后的样式：\npush新页面tabBar自动隐藏，pop回显示tabBar 上面说如果用完全自定义的tabbar，我只能设置到等pop回的页面全部出现之后再让tabBar显示出来，这样十分不友好，我们如果实现手机微信类似这样的效果我们应该如何设置呢？注意红框部分\n我们应该在要push出新页面的那个页面设置viewDidAppear和viewWillDisappear方法：\n- (void) viewDidAppear:(BOOL)animated { [super viewWillAppear:animated]; [self setHidesBottomBarWhenPushed:YES]; } - (void) viewWillDisappear:(BOOL)animated { [self setHidesBottomBarWhenPushed:NO]; [super viewDidDisappear:animated]; } 边缘拖动返回的时候，即可实现如下效果：\n完成~ 😏😏😏\n","description":"","tags":["iOS"],"title":"UITabBarController嵌套UINavigationController后，关于tabBar的问题以及解决方法","uri":"/posts/how-to-use-sethidebottombarwhenpushed/"},{"categories":null,"content":"UIImageView三种contentMode区别：UIViewContentModeScaleToFill、UIViewContentModeScaleAspectFit、UIViewContentModeScaleAspectFill\n原图片： UIViewContentModeScaleToFill： UIViewContentModeScaleAspectFit UIViewContentModeScaleAspectFill ","description":"","tags":["iOS"],"title":"UIImageView 中图片的几种常用适应方式","uri":"/posts/some-uiimageview-fit-way/"},{"categories":null,"content":"今天在学习iOS开发的时候，偶然发现tableView有两种重用cell的方法。先整理一下方便日后查阅。\n第一种：[tableView dequeueReusableCellWithIdentifier:identifier] （SDK 6.0之前）\n第二种：[tableView dequeueReusableCellWithIdentifier:identifier forIndexPath:indexPath]] （SDK 6.0之后）\n区别： 第一种：必须判断cell是否定义，未定义则手动创建，代码如下：\nconst NSString *identifier = @\"cell\"; UITableView *cell = [tableView dequeueReusableCellWithIndetifier:identifier]; if(!cell) { cell = [[UITableView alloc] initWithStyle:UITableViewCellStyleDefault]; } /* 设置cell cell.textLable.text = @\"第...行\"; */ return cell; 第二种是SDK 6.0开始新添加的方法。用于你已经用Nib定义了一个Cell，然后就可以省下上面那些代码，只用一行就可以解决：\nUITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@\"cell\" forIndexPath:indexPath]; /* 设置cell cell.textLable.text = @\"第...行\"; */ 所以如果有这个错误：\nreason: 'unable to dequeue a cell with identifier friendCell - must register a nib or a class for the identifier or connect a prototype cell in a storyboard' 应该想一下自己是不是为cell创建的Nib。\n","description":"","tags":["iOS"],"title":"tableView 两种重用cell的方法区别","uri":"/posts/two-methods-to-reuse-cell/"},{"categories":null,"content":"Markdown 介绍 Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的使用十分简单，常用的标记其实就十几个，所以相对于HTML这种复杂的标记语言来说，Markdown是十分轻量的标记语言。\nMarkdown的基本使用 加粗和斜体 *斜体* _斜体_\n只要用一个_或者一个#包裹文字，即可实现文字斜体。\n**加粗文字** __加粗文字__\n只要用两个_或者两个#包裹文字，即可实现文字粗体。\n链接与图片 插入链接和图片的格式很相似，只有一个!的区别\n链接格式为：[链接文字](链接地址)\n图片格式为：![图片名字](图片地址)\n在Markdown中插入图片地址要用到图床，我用到的是围脖图床修复计划和云图图床，上传图片就可以生成URL\n标题 标题是文章中最常用的文本格式，在Markdown中只要在一行文字前添加#，即可标记为标题格式。\n＃ 一级标题\n## 二级标题\n### 三级标题\n以此类推，Markdown一共有六级标题，六级标题只需要加上六个######即可。\n列表 列表有有序列表和无序列表\n有序列表格式：\n1. 红色 2. 蓝色 3. 黑色 无序列表格式：\n* 红色 * 蓝色 * 黑色 引用 引用只需要在文字前面加上 \u003e 就可以了。你可以联合其它的标记符一起使用。\n\u003e * 引用中列表 \u003e * 列表 \u003e ### 引用中三级标题 \u003e\u003e 二级引用 行内代码和代码块 行内代码格式： ｀这里写代码｀\n代码块格式： 只要比上一行进行右缩进即可。按键盘tab键可以实现缩进\n表格 表格应该是Markdown中最难的标记了\n最简单的表格：\n| First Header | Second Header | Third Header | | ------------ | ------------- | ------------ | | Content Cell | Content Cell | Content Cell | | Content Cell | Content Cell | Content Cell | 你也可以设置文字的对齐方式\nFirst Header | Second Header | Third Header :----------- | :-----------: | -----------: Left | Center | Right Left | Center | Right 水平分隔线 使用 --- 或者 ***即可。\n删除线 删除线格式：\n~~删除线~~ 换行 只要在文字每行文字后面加上两个或两个以上的空格即可实现换行\n注意 标记符号后面一定加上空格 标记语言必须使用英文符号 如果使用正确而不起作用，换一行再试一次 Markdown编辑工具 本人使用的工具是Mac OS下的Mou,支持实时预览，文章中的截图即为Mou的截图。你也可以在Github上搜索其它主题样式进行安装。\nMac下Markdown编辑器：Mou ¥0、Byword ¥40、iA Writer ¥128、Ulysses ¥283 etc.\nWindows下Markdown编辑器：MarkdownPad、MarkPad etc.\n官方文档 英文Markdown文档\n中文Markdown文档\n","description":"","tags":["Markdown","Hexo"],"title":"MarkDown基本使用方法","uri":"/posts/markdown-base-use/"},{"categories":null,"content":"罗列了UIscrollView的一些基本设置和常用方法\n(void)viewDidLoad { [super viewDidLoad]; // [self initScrollView]; // [self initPageCtrl]; // [self addTimer]; self.scrollView = [[UIScrollView alloc]initWithFrame:CGRectMake(10, 20, 320, 460)]; self.scrollView.backgroundColor = [UIColor blueColor]; //是否支持滑动到最顶端 self.scrollView.scrollsToTop = NO; //设置UIScrollView的代理 self.scrollView.delegate = self; //设置内容大小 self.scrollView.contentSize = CGSizeMake(320 * 10, 460); //是否反弹 self.scrollView.bounces = NO; //是否滚动 self.scrollView.scrollEnabled = YES; //是否分页 self.scrollView.pagingEnabled = NO; //设置indecator风格 self.scrollView.indicatorStyle = UIScrollViewIndicatorStyleWhite; //设置内容边缘和Indicator边缘 self.scrollView.contentInset = UIEdgeInsetsMake(0, 50, 50, 0); self.scrollView.scrollIndicatorInsets = UIEdgeInsetsMake(0, 50, 0, 0); //是否同时运动 self.scrollView.directionalLockEnabled = NO;\n[self.view addSubview:self.scrollView]; }\n//是否支持滑动到顶部\n(BOOL) scrollViewShouldScrollToTop:(UIScrollView *)scrollView { return YES; } //滑动到顶部时调用该方法\n(void) scrollViewDidScrollToTop:(UIScrollView *)scrollView { NSLog(@“滑动到顶部了”); } //已经滑动(正在滑动也会调用该方法)\n(void) scrollViewDidScroll:(UIScrollView *)scrollView { NSLog(@“已经开始滑动”); } //开始拖动\n(void) scrollViewWillBeginDragging:(UIScrollView *)scrollView { NSLog(@“开始拖动”); } //结束拖动\n(void) scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { NSLog(@“结束拖动”); } //开始减速\n(void) scrollViewWillBeginDecelerating:(UIScrollView *)scrollView { NSLog(@“开始减速”); } //减速停止\n(void) scrollViewDidEndDecelerating:(UIScrollView *)scrollView { NSLog(@“减速停止”); } //结束滚动动画\n(void) scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView { NSLog(@“结束滚动动画”); }\n(void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. }\n","description":"","tags":["iOS"],"title":"UIScrollView的基本属性设置和常用代理方法","uri":"/posts/how-to-use-uiscrollviewdelegate/"},{"categories":null,"content":"-(BOOL)respondsToSelector: selector //用来判断是否有以某个名字命名的方法（被封装在一个selector的对象里传递）\n@protocol appViewDelegate \u003cNSObject\u003e @optional - (void) theButtonOnClicked:(UIButton *)button; @end if([self.delegate respondsToSelector:@selector(theButtonOnClicked:)]) { self.delegate theButtonOnClicked:sender; } #pragma mark - appViewDelegate - (void) theButtonOnClicked:(UIButton *)button { button.enabled = NO; []button setTitle:@\"已下载\" ForState:UIControlStateDisabled]; } ","description":"","tags":["IOS"],"title":"函数respondsToSelector的使用","uri":"/posts/how-to-use-founction-respondstoselector/"},{"categories":null,"content":"这一篇是本系列的最后一篇，到目前为止，我们搭建的Hexo博客已经能满足我们日常的需求。可是有没有想过我们其实只能在这一台电脑上更新我们的博客？如果有一天我换了一台电脑，或者公司和家里不同的电脑都想更新博客，应该怎么办呢？\n这里只给类似我这样的git新人做参考，git的很多用法我也不太熟练。如果有错误还请各位指正。\nNote: 这里需要注意的是，当我们执行$ hexo deploy，部署到Github 上面的是hexo给我们生成的静态页面，并不是整个hexo博客工程文件，所以并不能简单的在不同PC的更新博客。\n其实有两种办法，第一就是**把整个目录备份到云盘，然后开启云盘同步该文件夹，虽然操作简单，但是同步很麻烦，需要手动将文件夹进行覆盖。第二种就是使用Git的第三方服务** ，只要配置完成，不管到哪里，用哪台电脑都能简单实现更新博客（当然需要Node.js和Git运行环境，在我们本系列的第一篇有讲解）。\n在本文中详细讲解如何使用第三方git服务进行博客的备份。可以Github放在共有仓库，如果你担心泄密，可以用Github 的私有仓库（收费），国内除了Github 还有许多知名的git服务商，如：gitcafe，bitbucket，oschina，coding等，据我了解，oschina的私有仓库是免费的，而且可以和Github 进行同步。因为我们的博客放在了Github，所以我们不妨就把我们博客程序也同步到Github的仓库中。\n下面我们就来讲解如何实现不同电脑同时更新博客。\n将我们的博客目录备份到Github，实现多PC维护 在Github网站创建一个新的repository 我们在这里给新创建的repository命名为blog；\n不会创建方法的朋友可以参考在Github上面搭建Hexo博客（一）中的创建方法。\n在A电脑中从本地上传Hexo到Github仓库 Note: A电脑指的是建立Hexo博客的电脑。\n初始化仓库 在Hexo博客的根目录运行Git Bash并输入以下命令：\n\u003e git init \u003e git remote add origin \u003cserver address\u003e 这里\u003cserver\u003e指的是在线仓库的地址，比如在这里我的就应该是https://github.com/Gitzhaoyang/blog.git，如果你用其它git仓库服务，填写对应仓库地址即可。 origin是本地分支,remote add会将本地仓库映射到Github仓库\n把本地文件同步到Github上面 分别输入执行以下命令：\n\u003e git add . #添加所有目录，注意add后面有个点`.` \u003e git commit -m \"add to Github\" #添加提交说明，每次提交都需要 \u003e git push -u origin master #把更新推送到云端 这时可以登录Github账户查看刚创建的blog仓库中是否上传成功\nwindows平台可能push过程中会提示输入Github的用户名和Github的密码，输入正确便是。\n注意 为了在另一台电脑上配置更加方便，严重建议把Hexo博客目录下_config.yml文件复制粘贴一份，并重命名为hexo_config.yml；把themes目录下你用到主题目录下的_config.yml 文件也复制一份，并粘贴到博客根目录，注意，是’博客根目录’，并命名为theme_config.yml。原因是我们上传的时候，我们自己安装的themes 如：[NexT](http://theme-next.iissnan.com)，它的'next'目录并不能上传，所以我们需要把这两个配置文件都保存下来在进行同步工作。\n在B电脑中从Github仓库取回Hexo到本地 Note: B电脑指的是另一台电脑，如果没有另一台电脑也可以找地方新建一个文件夹尝试。\n安装Git和Node.js 值得注意的是新电脑也需要安装Git和Node.js环境，参考本系列的第一篇中安装方法。\n把文件取回本地 安装环境完成后，在新文件夹下运行Git Bash并分别执行以下几条命令：\n\u003e git init $ git remote add origin \u003cserver\u003e \u003e git fetch --all $ git reset --hard origin/master 这里\u003cserver\u003e仍然是你的Giuhub地址。fetch是将仓库中的内容取出来。reset则是不做任何合并（merge）处理，直接把取出的内容保存。\n运行完reset后你会发现文件夹中就会出现刚刚上传的内容。但是配置并没有完成，请继续往下看。\n配置新的Hexo Note: 如果是新PC，不要忘记我们本机并没有安装Hexo博客\n首先，在刚才的目录下执行以下命令以在新机器中安装Hexo\n$ npm install hexo --save 初始化Hexo并安装相应依赖包\n\u003e hexo init \u003e npm intall 记得在第一篇中讲过，新安装的Hexo是没有hexo-deployer-git依赖包的，需要手动安装\n\u003e npm install hexo-deployer-git --save 如果你在A机器上设置了订阅（feed），那么你需要重新烧制feed，需要重新安装依赖包，没有设置feed的可以略过\n\u003e npm install hexo-generation-feed --save 安装主题，我在上文中提到新安装的主题并不能被上传，所以也需要重新手动安装(以NexT主题为例)\n\u003e git clone https://github.com/iissnan/hexo-theme-next themes/next 这里要注意的是：themes/next是主题保存目录。\n我们之前备份的两个配置文件hexo_config.yml和theme_config.yml有用了,hexo_config.yml重命名为_config.yml 覆盖根目录下的同名文件，而theme_config.yml也重命名为_config.yml覆盖主题目录下的config.yml文件。注意文件名前面的下划线’_’。\n输入命令 $ hexo generate 和命令 $ hexo server ， 然后在浏览器输入 localhost:4000 中进行预览。 如果没有问题那么我们在B电脑上就配置成功了。\n在B电脑上更新博客 现在在B电脑上也可以像在A电脑上一样更新博客了，同样是$ hexo new post \"my_new_post\" 编辑完文章，然后执行$ hexo generate和$ hexo deploy就可以成功发表了。 这里$ hexo deploy命令是将我们的博客文章发表到我们的Github 上的Hexo博客，并不是前文新建的blog仓库，新建的blog仓库用来保存我们的Hexo程序。\n把B电脑上的Hexo从本地同步到Github仓库 当发表完文章，我们还需要把Hexo程序同步到我们Github的blog仓库。执行下面指令：\n$ git add .\n这是可以输入命令$ git status查看状态，回显示刚才编辑过的文件的信息。\n之后分别输入下面指令完成上传：\n$ git commit -m “commit from PC_B” $ git push -u origin master\n成功后，我们再次把程序同步更新到了我们的Github仓库blog。 如果再想用A电脑更新我们的博客，只需要在执行添加文章之前先把程序从blog仓库拉取下来便可。输入命令：\n\u003e git pull https://github.com/Gitzhaoyang/blog.git 即可完成。\n注意事项 我们每次更新博客时，为了保持我们每次用到的程序都是最新的。\n每次更新博客之前都需要执行$ git pull https://github.com/xxxx/xxx.git保持本地最新；\n每次更新博客之后都需要执行 $ git add . , $ git commit -m \"message\" , $ git push -u origin master 以保持 Github 仓库程序最新。\n好了，现在我们就能实现在不同电脑都能对我们的Hexo博客进行维护了。😎😘\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（四）:使用不同电脑维护","uri":"/posts/create-hexo-on-github-4/"},{"categories":null,"content":"更换主题很简单，首先感谢@iissnan，因为博主用的是@iissnan的NexT主题，所以本文就以NexT主题为例讲解如何更换博客主题。在文末我会给出更多优秀主题的Github地址。\n为自己的Hexo博客更换主题 我这里讲到的也是参考了NexT主题作者的使用文档，更详细的设置读者们可以直接去参考该使用文档。\n下载NexT主题包 仍然在博客根目录下运行Git bash命令行工具，输入下面一条指令用以克隆最新版本：\n\u003e git clone https://github.com/iissnan/hexo-theme-next theme/next 启用主题 下载完成后，打开博客配置文件_config.theme，修改里面的theme字段，将其值设置为next\n验证主题是否启用成功 在Git Bash中输入$ npm server启用本地服务，然后在浏览器中输入localhost:4000进行预览即可\n更多详细的设置，不再赘述，可以参考NexT的使用文档\n其他优秀的主题推荐： iissnan/hexo-theme-next TryGhost/Casper daleanthony/uno orderedlist/modernist litten/hexo-theme-yilia A-limon/pacman AlxMedia/hueman kathyqian/crisp-ghost-theme 更多优秀的主题可以参考知乎回答：有哪些好看的hexo主题?－家顺张的回答\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（三）：更换Hexo主题","uri":"/posts/create-hexo-on-github-3/"},{"categories":null,"content":"如何配置Hexo 上一节中我们已经在本地和Github上搭建起了自己的博客，但是博客的配置都是默认值，如果我们想个性化自己的博客，我们应该做什么呢。这一节中我们一起来配置自己的博客的基本信息和介绍如何写博客和发表博客。下一节我们将一起为自己的博客安装新的主题。\n博客的主要配置用到根目录下的_config.yml文件，我在下面给出文件和解释，你只需要根据自己需求作出简单更改即可：\n# Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Mungo's Note##站点的名字 subtitle:##站点的副标题 description: 日常技术分享 ##站点介绍，对站点进行描述 author: Mungo##站点文章的作者 email: gmzhaoyang@gmail.com##你的邮箱地址 language:##语言，默认中文，不填写即可 timezone:##时区，默认即可 # URL ## If your site is put in a subdirectory, ## set url as 'http://yoursite.com/child' and root as '/child/' url: http://mungo.space##站点的域名，如果奇怪我为什么可以用自己的域名，可以看后续更新 root: / permalink: :year/:month/:day/:title/ permalink_defaults: ## 对资源文件夹的配置，如资源文件夹名称，标签云名称，分类页面名称 # Directory source_dir: source##资源文件夹,当执行`$ hexo deloy`命令，上传的即是该文件夹里面的内容 public_dir: public##公共文件夹，当执行`$ hexo generate`命令，生成的文件都在里面 tag_dir: tags##标签云文件夹，需要自己生成，详情见下一节如何配置主题 archive_dir: archives##归档文件夹，需要自己生成 category_dir: categories##分类文件夹，需要自己生成 code_dir: downloads/code##代码存放区 i18n_dir: :lang skip_render: ##此处时配置博客文章内容格式的，可以保持默认，不做修改 # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true auto_detect: true tab_replace: #分类和标签云的配置，可以不做修改，默认即可 # Category \u0026 Tag default_category: uncategorized category_map: tag_map: #日期和时间格式的配置，可以不做修改，默认即可 # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss #用来配置每页显示的文章数目，可以根据自己需求自行修改 # Pagination ## Set per_page to 0 to disable pagination per_page: 10 pagination_dir: page #插件和主题配置，在这里可以修改自己的主题 # Extensions ## Plugins: http://hexo.io/plugins/ ## Themes: http://hexo.io/themes/ theme: next #上传配置，上一节中我们已经配置完成了，在这里不需要再次修改 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: https://github.com/Gitzhaoyang/gitzhaoyang.github.io.git branch: master 当配置完成并保存后，就可以执行$ hexo generate生成静态文件，然后执行$ hexo server后就可以打开浏览器输入localhost:4000进行本地预览了\ntips 如果_config.yml文件打开有乱码应该是用到的编辑器的原因，我用的是Sublime2，所以一般不会出现乱码。如果乱码，那么需要把文件格式转换为UTF-8，转化方法我在这里就不再赘述了。\n如何添加和发表文章 新建文章 在Git Bash中输入\n$ hexo new post “my_first_post”\n编辑文章 第一步的命令会在\\Hexo\\source\\_posts文件夹下创建一个后缀.md文件，你可以在里面添加任何字符串。\n这其实是一个markdown类型的文件，使用markdown语言编写，我这篇博文就是用markdown编写的，如果不了解的，可以看我的后续更新，我会把markdown的基本使用方法进行整理。\n生成和上传 在GitBash中输入$ hexo generate对文件进行生成；\n生成完成后，可以输入$ hexo server，然后在浏览器输入localhost:4000进行预览；\n预览没有问题后，接着输入$ hexo deploy，windows平台下会提示输入Github的用户名，然后提示输入Github的登录密码。如果输入正确，等待几秒便能上传成功；\n现在可以在浏览器中输入xxxx.github.io进行访问了。\n注意 可能不会立即生效，只要等待几分钟或者清空一下浏览器缓存基本就能解决。如果仍然看不到，说明前面步骤操作有错误，重新生成和上传就可以了。\n如果实在不行，可以在Git Bash中输入$ hexo clean或者手动删除.deploy_git文件夹和db.json文件再重新生成和上传。\n到目前为止，我们已经搭建起自己的博客，可以进行基本的配置，也可以发表文章，后面会有更高阶的设置，如：如何配置主题，如何在不同电脑上都可以更新自己的博客 etc.感兴趣的人可以关注。😘\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（二）：配置和发表文章","uri":"/posts/create-hexo-on-github-2/"},{"categories":null,"content":"什么是SSH SSH为Secure Shell的缩写，是建立在应用层和传输层基础上的协议。SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用SSH协议可以有效防止远程管理中额信息泄漏问题。我理解的就是给数据进行加密，然后防止中间人进行盗取，能使你的数据安全可靠的传输到目的方。在这里就是为了保证你电脑和Github仓库之间通信的安全。\n如何配置Github的SSH 题主这里用的依然是windows平台。\nStep 1: 检查SSH keys 首先，我们要查看在你电脑上已经存在的SSH keys。运行Git Bash 然后输入：\n$ ls -al ~/.ssh 如果你已经有SSH公钥了。那么你将会看到下面格式的文件名字：\nid_dsa.pub id_esdsa.pub id_ed25519.pub id_rsa.pub 如果你已经存在公钥了，那么可以跳过Step 2直接去Step 3了。如果没有也不要担心，我们将在Step 2 会创建公钥。\nStep 2: 生成SSH key 在Git Bash中输入下面命令，引号内一定是你的Github注册邮箱地址 $ ssh-keygen -t rsa -b 4096 -C \"your_github_email@example.com\" #这句作用是生成一个新的SSH key 等待几秒，当提示让你输入保存地址时，官方特别推荐放在默认位置就可以了。所以这里直接输入回车，提示如下： Enter file in which to save the key (/Users/you/.ssh/id_rsa):[直接输入回车] 将会提示你输入一个密码串**(这里输入密码时不会显示在屏幕上的，只要输入正确按回车就好)**: Enter passphrase （empty for no passphrase）: [输入你想设置的密码] Enter same passphrase again：[在输入一遍密码] ＃虽然说这里可以设置为空，但是推荐用一个更加安全的密码 输完密码之后，你将会得到你的SSH的指纹(fingerprint)或者id。他看起来如下图： Step 3: 把你的SSH key添加到ssh-agent 输入如下命令 $ ssh-agent -s 会响应：\necho Agent pid [端口号] 加下来输入如下命令，把你的SSH key添加到ssh-agent $ ssh-add ~/.ssh/id_rsa 如果他提示如下，说明不能打开您身份验证的代理\nCould not open a connection to your authentication agent. 只需要输入如下命令即可解决：\nssh-agnet bash 更多关于ssh-agent的细节，可以用man ssh-agent 来查看\nStep 4: 把你的SSH key添加到你的Github账户 首先你应该把你的 SSH key 复制到你的剪贴板，输入命令即可完成把 SSH key 复制到你的剪贴板：\n$ clip \u003c ~/.ssh/id_ras.pub 添加到你的Github账户：\n浏览器登陆你的Github账户，点击右上角你的头像，然后点击Settings 进入Settings，点击侧栏选项SSH key 单击右边 Add SSH key 按钮 在下面输入标题（Title，这个可以自定义）和SHH Key（直接 Ctrl＋V 粘贴就可以） 点击下面的Add key按钮便可以添加成功了 Step 5: 测试是否连接成功 在Git Bash中输入： $ ssh -T git@github.com # ssh尝试连接到GitHub 你可能看到下面的警告： The authenticity of host 'github.com(207.97.227.239)' can't be established. RSA key fingerprint is SHA256:nJKJFKDnDLFJDndndnfkdfldjfldldfjld. Are you sure you want to continue connecting (yes/no)? 确定提示信息里的指纹（fingerprint）是否匹配，如果匹配就键入｀yes｀，将得到：\nHi [你的用户名]! You've successfully authenticated, but GitHub does not provide shell access. 如果提示信息中你的用户名是你的，那么你就成功建立了SSH key！😎😎 TIPS：如果遇到其他问题，可以参考官方文档，也可以给我留言 ","description":"","tags":["Github","SSH"],"title":"如何配置Github的SSH key","uri":"/posts/how-to-config-ssh-on-github/"},{"categories":null,"content":"什么是Hexo Hexo是一个基于Node.js的静态博客程序，可以方便的生成静态网页托管在Github和Heroku上。并且有很多人为其制作了很多优秀的主题（theme），你可以根据自己的喜好进行设置。主题的设置将在后面的章节中介绍。\n这个是Hexo官方网站介绍：\nHexo is a fast, simple and powerful blog framework. You write posts in Markdown (or other languages) and Hexo generates static files with a beautiful theme in seconds.\n翻译过来就是：\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章， 在几秒内，即可利用靓丽的主题生成静态网页。\n怎么在Github上搭建一个hexo博客 我用了一天时间研究和搭建了一个Github博客(GitHub Pages site)，过程中遇到一些小问题，现在写一篇教程，方便和我一样爱折腾但是是新手的人。\n注意 因为题主在搭建时在Windows平台，所以讲解为Windows版本，但是各个平台大同小异，所以实践起来并没有很大的差别。\n以下为教程正文：\n安装Git 前往Git官网下载Windows版本压缩包，下载完成后解压安装。\n安装Node.js 前往Node.js官方下载网站，下载Node.js官方安装包，下载完成后同样解压安装。\n安装Hexo 到目前为止，安装Hexo所需要的环境已将安装完成，下一步只需要安装Hexo便可以了。 点击鼠标右键，看是否有Git bash Here选项。如果没有可以前往Git安装根目录，启动git-base.exe也可以。 在命令行中输入：\n$ npm install -g hexo-cli\nHexo 便安装完成了\n创建Hexo文件夹 找到想要放置博客的文件夹，比如（F:\\Hexo），在该目录下鼠标右击打开Gitbash工具，（右键菜单中没有该选项的可以用cmd命令cd等进入该文件夹）。执行下面的语句，会在F:\\Hexo文件夹下创建node_modules 文件夹：\n\u003e hexo init 这里 init 后面可以跟文件目录，比如我想在F:\\Hexo下创建博客文件夹，那么可以用下面的命令：\n$ hexo init F:\\Hexo\n安装依赖包 在Hexo目录下，执行以下命令，你会发现F:\\Hexo\\node_modules目录下多了好多文件夹\n\u003e npm install 本地调试 目前为止，已经搭建好自己的Hexo博客了，但是只能在本机上查看。 执行以下两个命令（在F:\\Hexo目录下），然后在浏览器中输入 localhost:4000 就可以看到自己的博客了\n\u003e hexo generate \u003e hexo serrver 但是只能在本地查看，如果想让别人也能访问，那么就需要部署到Github 上面，下面，我们就部署上去。\n注册Github账户 前往Github网站，注册一个新用户。用邮箱注册的一定前往邮箱去验证邮件。要不然之后可能会有小问题。\n创建一个新的repository 在自己的Github主页右下角,创建一个新的repository。 比如我的Github用户名为Gitzhaoyang，那么我创建的repository的名字应该是 gitzhaoyang.github.io 。\n这里严重注意 一定要以你的Github用户名.github.io创建。假如我没有用gitzhaoyang.github.io而是用了mungo.github.io ，那么当我浏览器访问博客的时候会出现404错误。这里并不是没有部署成功，而是把它部署在了这里:http://gitzhaoyang.github.io/mungo.github.io。所以，如果想直接gitzhaoyang.github.io访问，那么就需要和用户名保持一致。题主在这里吃了不小的苦头，最后给Github客服发邮件才知道原因。\n创建好如下图：\n将本地的文件部署（上传）到Github账户中 编辑本地Hexo目录下文件_comfig.yml，在最后添加如下代码（在你修改时，把 gitzhaoyang 要替换成你自己的用户名）\ndeploy: type: git repository: http://github.com/Gitzhaoyang/gitzhaoyang.github.io.git branch: master .yml文件对格式规范要求很严格，type: repository: branch: 前面有两个空格，冒号后面都有一个空格。\n执行以下指令即可完成部署（如果提示错误，可以看下面注意）：\n\u003e hexo generate \u003e hexo deploy 注意事项 有些用户没有设置Github的SSH，会导致上面两句失败。SSH的介绍和设置方法可以查看 官方教程,配置起来很简单。 如果英文看不明白或者过程中出现小问题， 可以查看我写的 SSH设置教程 ，是对官方教程的解释和扩展， 针对配置过程中的小问题都有解决办法。\n每次修改本地文件，都需要命令$ hexo generate才能保存。而且每次使用命令都必须在 Hexo 根目录下使用。\n如果你在执行$ hexo deloy,如果提示 ERROR Deployer not found: git，那说明你没有安装hexo-deployer-git依赖包，进入F:\\Hexo\\node_modules 发现真的没有hexo-deployer-git，不用担心，只需要输入下面命令创建hexo-deployer-git依赖包，然后再执行hexo deploy就能上传成功了\n\u003e npm install hexo-deployer-git --save 如果你是windows用户，那么当你执行$ hexo deploy命令的时候， 可能会先后出现提示框让你输入你的Github用户名和Github密码，只要输入正确，上传就没有问题。\n好了，现在我们的博客已经在Github上面部署成功了，可以在浏览器访问gitzhaoyang.github.io试试了。\n提示 现在Hexo支持更加简单的命令格式了，比如：\nhexo s == hexo server hexo g == hexo generate hexo d == hexo deploy hexo n == hexo new 后续我会把如何配置博客信息，发表文章，设置博客主题，不同电脑间进行同时更新自己的Blog的方法等更新上来,感兴趣的人可以关注\n","description":"","tags":["Hexo","Github"],"title":"在Github上面搭建Hexo博客（一）：部署到Github","uri":"/posts/create-hexo-on-github-1/"}]